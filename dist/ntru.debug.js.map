{"version":3,"file":"dist/ntru.debug.js","sources":["libsodium/src/libsodium/randombytes/randombytes.c","NTRUEncrypt/src/ntru_crypto_drbg.c","NTRUEncrypt/src/ntru_crypto_hash.c","NTRUEncrypt/src/ntru_crypto_hmac.c","NTRUEncrypt/src/ntru_crypto_msbyte_uint32.c","NTRUEncrypt/src/ntru_crypto_ntru_convert.c","NTRUEncrypt/src/ntru_crypto_ntru_encrypt.c","NTRUEncrypt/src/ntru_crypto_ntru_encrypt_key.c","NTRUEncrypt/src/ntru_crypto_ntru_encrypt_param_sets.c","NTRUEncrypt/src/ntru_crypto_ntru_mgf1.c","NTRUEncrypt/src/ntru_crypto_ntru_mult_coeffs_karat.c","NTRUEncrypt/src/ntru_crypto_ntru_mult_indices.c","NTRUEncrypt/src/ntru_crypto_ntru_poly.c","NTRUEncrypt/src/ntru_crypto_sha1.c","NTRUEncrypt/src/ntru_crypto_sha2.c","NTRUEncrypt/src/ntru_crypto_sha256.c","ntru.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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A;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;AAIA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAKA;AAAA;AACA;AAAA;;;;;;;;;;;;;;ACvSA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;AAQA;;;;;;;;;;;;;;AAsBA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;AAQA;;;;;;;;;;;;;;;;;;;;;AC/BA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AA8BA;;AAvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AACA;AAAA;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAKA;;;;;;;;;;;;;;;;;;;;;;AAmBA;;AAKA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAEA;AACA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AACA;;AAEA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;;AAEA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;AAoBA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;AAA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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;AC5OA;AAAA;AAAA;;;;;;;;;;;;AAqBA;AAAA;AACA;AADA;AAAA;;;;;;;;;;AAqBA;AACA;AADA;AAAA;;;;;;;;;;;;;AAuBA;AACA;AAAA;AADA;AAAA;;;;;;;;;;ACpGA;AAAA;AAAA;AACA;;;;;;AAIA;AACA;AAMA;AADA;AAKA;AADA;AASA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;AAGA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;;;;;;;;;;AAQA;AAGA;AAEA;AANA;AAAA;;;;;;;;;;;;;;AAiBA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAPA;AAAA;;;;;;;;;;;;;;AAgBA;AAAA;AAGA;AACA;AACA;AACA;AAEA;AANA;AAAA;AASA;AAAA;;AACA;AAAA;AAAA;AAKA;AAAA;;AAFA;AAAA;AAAA;AAEA;AAAA","sourcesContent":["\n#include <stdlib.h>\n#include <sys/types.h>\n\n#include <assert.h>\n#include <limits.h>\n#include <stdint.h>\n\n#ifdef __EMSCRIPTEN__\n# include <emscripten.h>\n#endif\n\n#include \"randombytes.h\"\n#include \"randombytes_sysrandom.h\"\n\n#ifdef __native_client__\n# include \"randombytes_nativeclient.h\"\n#endif\n\n/* C++Builder defines a \"random\" macro */\n#undef random\n\nstatic const randombytes_implementation *implementation;\n\n#ifdef __EMSCRIPTEN__\n# define RANDOMBYTES_DEFAULT_IMPLEMENTATION NULL\n#else\n# ifdef __native_client__\n#  define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_nativeclient_implementation;\n# else\n#  define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_sysrandom_implementation;\n# endif\n#endif\n\nstatic void\nrandombytes_init_if_needed(void)\n{\n    if (implementation == NULL) {\n        implementation = RANDOMBYTES_DEFAULT_IMPLEMENTATION;\n        randombytes_stir();\n    }\n}\n\nint\nrandombytes_set_implementation(randombytes_implementation *impl)\n{\n    implementation = impl;\n\n    return 0;\n}\n\nconst char *\nrandombytes_implementation_name(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->implementation_name();\n#else\n    return \"js\";\n#endif\n}\n\nuint32_t\nrandombytes_random(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->random();\n#else\n    return EM_ASM_INT_V({\n        return Module.getRandomValue();\n    });\n#endif\n}\n\nvoid\nrandombytes_stir(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->stir != NULL) {\n        implementation->stir();\n    }\n#else\n    EM_ASM({\n        if (Module.getRandomValue === undefined) {\n            try {\n                var window_ = \"object\" === typeof window ? window : self,\n                    crypto_ = typeof window_.crypto !== \"undefined\" ? window_.crypto : window_.msCrypto,\n                    randomValuesStandard = function() {\n                        var buf = new Uint32Array(1);\n                        crypto_.getRandomValues(buf);\n                        return buf[0] >>> 0;\n                    };\n                randomValuesStandard();\n                Module.getRandomValue = randomValuesStandard;\n            } catch (e) {\n                try {\n                    var crypto = require('crypto'),\n                        randomValueNodeJS = function() {\n                            var buf = crypto.randomBytes(4);\n                            return (buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3]) >>> 0;\n                        };\n                    randomValueNodeJS();\n                    Module.getRandomValue = randomValueNodeJS;\n                } catch (e) {\n                    throw 'No secure random number generator found';\n                }\n            }\n        }\n    });\n#endif\n}\n\n/*\n * randombytes_uniform() derives from OpenBSD's arc4random_uniform()\n * Copyright (c) 2008, Damien Miller <djm@openbsd.org>\n */\nuint32_t\nrandombytes_uniform(const uint32_t upper_bound)\n{\n    uint32_t min;\n    uint32_t r;\n\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->uniform != NULL) {\n        return implementation->uniform(upper_bound);\n    }\n#endif\n    if (upper_bound < 2) {\n        return 0;\n    }\n    min = (uint32_t) (-upper_bound % upper_bound);\n    do {\n        r = randombytes_random();\n    } while (r < min);\n\n    return r % upper_bound;\n}\n\nvoid\nrandombytes_buf(void * const buf, const size_t size)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (size > (size_t) 0U) {\n        implementation->buf(buf, size);\n    }\n#else\n    unsigned char *p = buf;\n    size_t         i;\n\n    for (i = (size_t) 0U; i < size; i++) {\n        p[i] = (unsigned char) randombytes_random();\n    }\n#endif\n}\n\nint\nrandombytes_close(void)\n{\n    if (implementation != NULL && implementation->close != NULL) {\n        return implementation->close();\n    }\n    return 0;\n}\n\nvoid\nrandombytes(unsigned char * const buf, const unsigned long long buf_len)\n{\n    assert(buf_len <= SIZE_MAX);\n    randombytes_buf(buf, (size_t) buf_len);\n}\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_drbg.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File:  ntru_crypto_drbg.c\n *\n * Contents: Implementation of a SHA-256 HMAC-based deterministic random byte\n *           generator (HMAC_DRBG) as defined in ANSI X9.82, Part 3 - 2007.\n *\n * This implementation:\n *   - allows for MAX_INSTANTIATIONS simultaneous drbg instantiations\n *     (may be overridden on compiler command line)\n *   - has a maximum security strength of 256 bits\n *   - automatically uses SHA-256 for all security strengths\n *   - allows a personalization string of length up to\n *     HMAC_DRBG_MAX_PERS_STR_BYTES bytes\n *   - implments reseeding\n *   - does not implement additional input for reseeding or generation\n *   - does not implement predictive resistance\n *   - limits the number of bytes requested in one invocation of generate to\n *     MAX_BYTES_PER_REQUEST\n *   - uses a callback function to allow the caller to supply the\n *     Get_entropy_input routine (entropy function)\n *   - limits the number of bytes returned from the entropy function to\n *     MAX_ENTROPY_NONCE_BYTES\n *   - gets the nonce bytes along with the entropy input from the entropy\n *     function\n *   - automatically reseeds an instantitation after MAX_REQUESTS calls to\n *     generate\n *\n *****************************************************************************/\n\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_drbg.h\"\n#include \"ntru_crypto_hmac.h\"\n\n\n/************************\n * HMAC_DRBG parameters *\n ************************/\n\n/* Note: Combined entropy input and nonce are a total of 2 * sec_strength_bits\n * of randomness to provide quantum resistance */\n#define HMAC_DRBG_MAX_MIN_ENTROPY_NONCE_BYTES                                 \\\n    (2 * DRBG_MAX_SEC_STRENGTH_BITS)/8\n#define HMAC_DRBG_MAX_ENTROPY_NONCE_BYTES                                     \\\n    HMAC_DRBG_MAX_MIN_ENTROPY_NONCE_BYTES * DRBG_MAX_BYTES_PER_BYTE_OF_ENTROPY\n#define HMAC_DRBG_MAX_REQUESTS            0xffffffff\n\n\n/*******************\n * DRBG structures *\n *******************/\n\n/* SHA256_HMAC_DRBG state structure */\n\ntypedef struct {\n    uint32_t              sec_strength;  /* security strength in bits */\n    uint32_t              requests_left; /* generation requests remaining\n                                            before reseeding */\n    ENTROPY_FN            entropy_fn;    /* pointer to entropy function */\n    NTRU_CRYPTO_HMAC_CTX *hmac_ctx;      /* pointer to HMAC context */\n    uint8_t               V[33];         /* md_len size internal state + 1 */\n} SHA256_HMAC_DRBG_STATE;\n\n\n/* External DRBG state structure */\n\ntypedef struct {\n    RANDOM_BYTES_FN   randombytesfn;\n} EXTERNAL_DRBG_STATE;\n\n\n/* DRBG state structure */\n\ntypedef struct {\n    uint32_t    handle;\n    DRBG_TYPE   type;\n    void       *state;\n} DRBG_STATE;\n\n\n/*************\n * DRBG DATA *\n *************/\n\n/* array of drbg states */\n\nstatic DRBG_STATE drbg_state[DRBG_MAX_INSTANTIATIONS];\n\n\n/******************************\n * SHA256 HMAC_DRBG functions *\n ******************************/\n\n/* sha256_hmac_drbg_update\n *\n * This routine is the SHA-256 HMAC_DRBG derivation function for\n * instantiation, and reseeding, and it is used in generation as well.\n * It updates the internal state.\n *\n * For instantiation, provided_data1 holds the entropy input and nonce;\n * provided_data2 holds the optional personalization string.  Combined, this\n * is the seed material.\n *\n * For reseeding, provided_data1 holds the entropy input;\n * provided_data2 is NULL (because this implementation does not support\n * additional input).\n *\n * For byte generation, both provided_data1 and provided_data2 are NULL.\n *\n * Returns DRBG_OK if successful.\n * Returns HMAC errors if they occur.\n */\n\nstatic uint32_t\nsha256_hmac_drbg_update(\n    SHA256_HMAC_DRBG_STATE *s,\n    uint8_t                *key,                    /* md_len size array */\n    uint32_t                md_len,\n    uint8_t const          *provided_data1,\n    uint32_t                provided_data1_bytes,\n    uint8_t const          *provided_data2,\n    uint32_t                provided_data2_bytes)\n{\n    uint32_t result;\n\n    /* new key = HMAC(K, V || 0x00 [|| provided data1 [|| provided data2]] */\n\n    if ((result = ntru_crypto_hmac_init(s->hmac_ctx)) != NTRU_CRYPTO_HMAC_OK)\n    {\n        return result;\n    }\n    \n    s->V[md_len] = 0x00;\n    \n    if ((result = ntru_crypto_hmac_update(s->hmac_ctx, s->V, md_len + 1)) !=\n            NTRU_CRYPTO_HMAC_OK)\n    {\n        return result;\n    }\n    \n    if (provided_data1) \n    {\n        if ((result = ntru_crypto_hmac_update(s->hmac_ctx, provided_data1,\n                  provided_data1_bytes)) != NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n            \n        if (provided_data2) \n        {\n            if ((result = ntru_crypto_hmac_update(s->hmac_ctx, provided_data2,\n                  provided_data2_bytes)) != NTRU_CRYPTO_HMAC_OK)\n            {\n                return result;\n            }\n        }\n    }\n    \n    if ((result = ntru_crypto_hmac_final(s->hmac_ctx, key)) !=\n            NTRU_CRYPTO_HMAC_OK)\n    {\n        return result;\n    }\n    \n    if ((result = ntru_crypto_hmac_set_key(s->hmac_ctx, key)) !=\n            NTRU_CRYPTO_HMAC_OK)\n    {\n        return result;\n    }\n    \n    /* new V = HMAC(K, V) */\n\n    if ((result = ntru_crypto_hmac_init(s->hmac_ctx)) != NTRU_CRYPTO_HMAC_OK)\n    {\n        return result;\n    }\n    \n    if ((result = ntru_crypto_hmac_update(s->hmac_ctx, s->V, md_len)) !=\n            NTRU_CRYPTO_HMAC_OK)\n    {\n        return result;\n    }\n    \n    if ((result = ntru_crypto_hmac_final(s->hmac_ctx, s->V)) !=\n            NTRU_CRYPTO_HMAC_OK)\n    {\n       return result;\n    }\n    \n    /* if provided data exists, update K and V again */\n\n    if (provided_data1) \n    {\n        /* new key = HMAC(K, V || 0x01 || provided data1 [|| provided data2] */\n\n        if ((result = ntru_crypto_hmac_init(s->hmac_ctx)) !=\n                NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n        \n        s->V[md_len] = 0x01;\n        \n        if ((result = ntru_crypto_hmac_update(s->hmac_ctx, s->V, md_len + 1)) !=\n                NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n        \n        if ((result = ntru_crypto_hmac_update(s->hmac_ctx, provided_data1,\n                provided_data1_bytes)) != NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n        \n        if (provided_data2) \n        {\n            if ((result = ntru_crypto_hmac_update(s->hmac_ctx, provided_data2,\n                  provided_data2_bytes)) != NTRU_CRYPTO_HMAC_OK)\n            {\n                return result;\n            }\n        }\n        \n        if ((result = ntru_crypto_hmac_final(s->hmac_ctx, key)) !=\n                NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n        \n        if ((result = ntru_crypto_hmac_set_key(s->hmac_ctx, key)) !=\n                NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n        \n        /* new V = HMAC(K, V) */\n\n        if ((result = ntru_crypto_hmac_init(s->hmac_ctx)) !=\n                NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n        \n        if ((result = ntru_crypto_hmac_update(s->hmac_ctx, s->V, md_len)) !=\n                NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n        \n        if ((result = ntru_crypto_hmac_final(s->hmac_ctx, s->V)) !=\n                NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n    }\n\n    memset(key, 0, md_len);\n    DRBG_RET(DRBG_OK);\n}\n\n\n/* sha256_hmac_drbg_instantiate\n *\n * This routine allocates and initializes a SHA-256 HMAC_DRBG internal state. \n *\n * Returns DRBG_OK if successful.\n * Returns DRBG_BAD_LENGTH if the personalization string is too long.\n * Returns DRBG_OUT_OF_MEMORY if the internal state cannot be allocated.\n * Returns errors from HASH or SHA256 if those errors occur.\n */\n\nstatic uint32_t\nsha256_hmac_drbg_instantiate(\n    uint32_t                 sec_strength_bits,  /* strength to instantiate */\n    uint8_t const           *pers_str,\n    uint32_t                 pers_str_bytes,\n    ENTROPY_FN               entropy_fn,\n    SHA256_HMAC_DRBG_STATE **state)\n{\n    uint8_t                 entropy_nonce[HMAC_DRBG_MAX_ENTROPY_NONCE_BYTES];\n    uint32_t                entropy_nonce_bytes;\n    uint32_t                min_bytes_of_entropy;\n    uint8_t                 num_bytes_per_byte_of_entropy;\n    uint8_t                 key[32];             /* array of md_len size */\n    SHA256_HMAC_DRBG_STATE *s;\n    uint32_t                result;\n    uint32_t                i;\n\n    /* check arguments */\n\n    if (pers_str_bytes > HMAC_DRBG_MAX_PERS_STR_BYTES)\n    {\n        DRBG_RET(DRBG_BAD_LENGTH);\n    }\n    \n    /* calculate number of bytes needed for the entropy input and nonce\n     * for a SHA256_HMAC_DRBG, and get them from the entropy source\n     */\n\n    if (entropy_fn(GET_NUM_BYTES_PER_BYTE_OF_ENTROPY,\n                   &num_bytes_per_byte_of_entropy) == 0)\n    {\n        DRBG_RET(DRBG_ENTROPY_FAIL);\n    }\n    \n    if ((num_bytes_per_byte_of_entropy == 0) ||\n            (num_bytes_per_byte_of_entropy >\n             DRBG_MAX_BYTES_PER_BYTE_OF_ENTROPY))\n    {\n        DRBG_RET(DRBG_ENTROPY_FAIL);\n    }\n    \n    min_bytes_of_entropy = (2 * sec_strength_bits) / 8;\n    entropy_nonce_bytes = min_bytes_of_entropy * num_bytes_per_byte_of_entropy;\n    \n    for (i = 0; i < entropy_nonce_bytes; i++)\n    {    \n         if (entropy_fn(GET_BYTE_OF_ENTROPY, entropy_nonce+i) == 0)\n         {\n            DRBG_RET(DRBG_ENTROPY_FAIL);\n         }\n    }\n    \n    /* allocate SHA256_HMAC_DRBG state */\n    s = (SHA256_HMAC_DRBG_STATE*) MALLOC(sizeof(SHA256_HMAC_DRBG_STATE));\n    if (s == NULL)\n    {\n        DRBG_RET(DRBG_OUT_OF_MEMORY);\n    }\n\n    /* allocate HMAC context */\n\n    memset(key, 0, sizeof(key));\n    if ((result = ntru_crypto_hmac_create_ctx(NTRU_CRYPTO_HASH_ALGID_SHA256,\n                    key, sizeof(key), &s->hmac_ctx)) != NTRU_CRYPTO_HMAC_OK)\n    {\n        FREE(s);\n        return  result;\n    }\n\n    /* init and update internal state */\n\n    memset(s->V, 0x01, sizeof(s->V));\n    if ((result = sha256_hmac_drbg_update(s, key, sizeof(key),\n                                       entropy_nonce, entropy_nonce_bytes,\n                                       pers_str, pers_str_bytes)) != DRBG_OK)\n    {\n        (void) ntru_crypto_hmac_destroy_ctx(s->hmac_ctx);\n        memset(s->V, 0, sizeof(s->V));\n        FREE(s);\n        memset(entropy_nonce, 0, sizeof(entropy_nonce));\n        return result;\n    }\n\n    memset(entropy_nonce, 0, sizeof(entropy_nonce));\n\n    /* init instantiation parameters */\n\n    s->sec_strength = sec_strength_bits;\n    s->requests_left = HMAC_DRBG_MAX_REQUESTS;\n    s->entropy_fn = entropy_fn;\n    *state = s;\n\n    return result;\n}\n\n\n/* sha256_hmac_drbg_free\n *\n * This routine frees a SHA-256 HMAC_DRBG internal state.\n *\n * Returns DRBG_OK if successful.\n * Returns DRBG_BAD_PARAMETER if inappropriate NULL pointers are passed.\n */\n\nstatic void\nsha256_hmac_drbg_free(\n    SHA256_HMAC_DRBG_STATE *s)\n{\n    if (s->hmac_ctx) \n    {\n        (void) ntru_crypto_hmac_destroy_ctx(s->hmac_ctx);\n    }\n    \n    memset(s->V, 0, sizeof(s->V));\n    s->sec_strength = 0;\n    s->requests_left = 0;\n    s->entropy_fn = NULL;\n    FREE(s);\n}\n\n\n/* sha256_hmac_drbg_reseed\n *\n * This function reseeds an instantiated SHA256_HMAC DRBG.\n *\n * Returns DRBG_OK if successful.\n * Returns HMAC errors if they occur.\n */\n\nstatic uint32_t\nsha256_hmac_drbg_reseed(\n    SHA256_HMAC_DRBG_STATE *s)\n{\n    uint8_t  entropy[HMAC_DRBG_MAX_ENTROPY_NONCE_BYTES];\n    uint32_t entropy_bytes;\n    uint32_t min_bytes_of_entropy;\n    uint8_t  num_bytes_per_byte_of_entropy;\n    uint8_t  key[32];  /* array of md_len size for sha256_hmac_drbg_update() */\n    uint32_t result;\n    uint32_t i;\n\n    /* calculate number of bytes needed for the entropy input\n     * for a SHA256_HMAC_DRBG, and get them from the entropy source\n     */\n\n    if (s->entropy_fn(GET_NUM_BYTES_PER_BYTE_OF_ENTROPY,\n                      &num_bytes_per_byte_of_entropy) == 0)\n    {\n        DRBG_RET(DRBG_ENTROPY_FAIL);\n    }\n    \n    if ((num_bytes_per_byte_of_entropy == 0) ||\n            (num_bytes_per_byte_of_entropy >\n             DRBG_MAX_BYTES_PER_BYTE_OF_ENTROPY))\n    {\n        DRBG_RET(DRBG_ENTROPY_FAIL);\n    }\n    \n    /* note: factor of 2 here is probably unnecessary, but ensures quantum\n     * resistance even if internal state is leaked prior to reseed */\n    min_bytes_of_entropy = (2 * s->sec_strength) / 8;\n    entropy_bytes = min_bytes_of_entropy * num_bytes_per_byte_of_entropy;\n    \n    for (i = 0; i < entropy_bytes; i++)\n    {\n        if (s->entropy_fn(GET_BYTE_OF_ENTROPY, entropy+i) == 0)\n        {\n            DRBG_RET(DRBG_ENTROPY_FAIL);\n        }\n    }\n\n    /* update internal state */\n\n    if ((result = sha256_hmac_drbg_update(s, key, sizeof(key),\n            entropy, entropy_bytes, NULL, 0)) != DRBG_OK)\n    {\n        return result;\n    }\n    \n    /* reset request counter */\n\n    s->requests_left = HMAC_DRBG_MAX_REQUESTS;             \n    DRBG_RET(DRBG_OK);\n}\n\n\n/* sha256_hmac_drbg_generate\n *\n * This routine generates pseudorandom bytes from a SHA256_HMAC DRBG.\n *\n * Returns DRBG_OK if successful.\n * Returns DRBG_BAD_LENGTH if too many bytes are requested or the requested\n *  security strength is too large.\n * Returns HMAC errors if they occur.\n */\n\nstatic uint32_t\nsha256_hmac_drbg_generate(\n    SHA256_HMAC_DRBG_STATE *s,\n    uint32_t                sec_strength_bits,\n    uint32_t                num_bytes,\n    uint8_t                *out)\n{\n    uint8_t  key[32];   /* array of md_len size for sha256_hmac_drbg_update() */\n    uint32_t result;\n\n    /* check if number of bytes requested exceeds the maximum allowed */\n\n    if (num_bytes > HMAC_DRBG_MAX_BYTES_PER_REQUEST)\n    {\n        DRBG_RET(DRBG_BAD_LENGTH);\n    }\n\n    /* check if drbg has adequate security strength */\n\n    if (sec_strength_bits > s->sec_strength)\n    {\n        DRBG_RET(DRBG_BAD_LENGTH);\n    }\n\n    /* check if max requests have been exceeded */\n\n    if (s->requests_left == 0)\n    {\n        if ((result = sha256_hmac_drbg_reseed(s)) != DRBG_OK)\n        {\n            return result;\n        }\n    }\n\n    /* generate pseudorandom bytes */\n\n    while (num_bytes > 0) \n    {\n        /* generate md_len bytes = V = HMAC(K, V) */\n\n        if ((result = ntru_crypto_hmac_init(s->hmac_ctx)) !=\n                NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n            \n        if ((result = ntru_crypto_hmac_update(s->hmac_ctx, s->V,\n                        sizeof(key))) != NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n\n        if ((result = ntru_crypto_hmac_final(s->hmac_ctx, s->V)) !=\n                NTRU_CRYPTO_HMAC_OK)\n        {\n            return result;\n        }\n\n        /* copy generated bytes to output buffer */\n\n        if (num_bytes < sizeof(key)) \n        {\n            memcpy(out, s->V, num_bytes);\n            num_bytes = 0;\n        } \n        else \n        {\n            memcpy(out, s->V, sizeof(key));\n            out += sizeof(key);\n            num_bytes -= sizeof(key);\n        }\n    }\n\n    /* update internal state */\n\n    if ((result = sha256_hmac_drbg_update(s, key, sizeof(key),\n                            NULL, 0, NULL, 0)) != DRBG_OK)\n    {\n        return result;\n    }\n    \n    s->requests_left--;\n\n    DRBG_RET(DRBG_OK);\n}\n\n\n/******************\n * DRBG functions *\n ******************/\n\n/* drbg_get_new_drbg\n *\n * This routine finds an uninstantiated drbg state and returns a pointer to it.\n *\n * Returns a pointer to an uninstantiated drbg state if found.\n * Returns NULL if all drbg states are instantiated.\n */\n\nstatic DRBG_STATE *\ndrbg_get_new_drbg()\n{\n    int i;\n\n    for (i = 0; i < DRBG_MAX_INSTANTIATIONS; i++) \n    {\n        if (drbg_state[i].state == NULL)\n        {\n            return drbg_state+i;\n        }\n    }\n    \n    return NULL;\n}\n\n\n/* drbg_get_drbg\n *\n * This routine finds an instantiated drbg state given its handle, and returns\n * a pointer to it.\n *\n * Returns a pointer to the drbg state if found.\n * Returns NULL if the drbg state is not found.\n */\n\nstatic DRBG_STATE *\ndrbg_get_drbg(\n    DRBG_HANDLE handle)             /* in/out - drbg handle */\n{\n    int i;\n\n    for (i = 0; i < DRBG_MAX_INSTANTIATIONS; i++) \n    {\n        if ((drbg_state[i].handle == handle) && drbg_state[i].state)\n        {\n            return drbg_state+i;\n        }\n    }\n    \n    return NULL;\n}\n\n\n/* drbg_get_new_handle\n *\n * This routine gets a new, unique 32-bit handle.\n *\n * Returns the new DRBG handle.\n */\n\nstatic DRBG_HANDLE\ndrbg_get_new_handle(void)\n{\n    DRBG_HANDLE h = 0;\n\n    /* ensure the new handle is unique:\n     *  if it already exists, increment it\n     */\n\n    while (drbg_get_drbg(h) != NULL)\n    {\n        ++h;\n    }\n\n    return h;\n}\n\n\n/********************\n * Public functions *\n ********************/\n\n/* ntru_crypto_drbg_instantiate\n *\n * This routine instantiates a drbg with the requested security strength.\n * See ANS X9.82: Part 3-2007. This routine currently returns an instance\n * of SHA-256 HMAC_DRBG for all requested security strengths.\n *\n * Returns DRBG_OK if successful.\n * Returns DRBG_ERROR_BASE + DRBG_BAD_PARAMETER if an argument pointer is NULL.\n * Returns DRBG_ERROR_BASE + DRBG_BAD_LENGTH if the security strength requested\n *  or the personalization string is too large.\n * Returns DRBG_ERROR_BASE + DRBG_NOT_AVAILABLE if there are no instantiation\n *  slots available\n * Returns DRBG_ERROR_BASE + DRBG_OUT_OF_MEMORY if the internal state cannot be\n *  allocated from the heap.\n */\n\nuint32_t\nntru_crypto_drbg_instantiate(\n    uint32_t       sec_strength_bits, /*  in - requested sec strength in bits */\n    uint8_t const *pers_str,          /*  in - ptr to personalization string */\n    uint32_t       pers_str_bytes,    /*  in - no. personalization str bytes */\n    ENTROPY_FN     entropy_fn,        /*  in - pointer to entropy function */\n    DRBG_HANDLE   *handle)            /* out - address for drbg handle */\n{\n    DRBG_STATE             *drbg = NULL;\n    SHA256_HMAC_DRBG_STATE *state = NULL;\n    uint32_t                result;\n\n    /* check arguments */\n\n    if ((!pers_str && pers_str_bytes) || !entropy_fn || !handle)\n    {\n        DRBG_RET(DRBG_BAD_PARAMETER);\n    }\n\n    if (sec_strength_bits > DRBG_MAX_SEC_STRENGTH_BITS)\n    {\n        DRBG_RET(DRBG_BAD_LENGTH);\n    }\n\n    if (pers_str && (pers_str_bytes == 0))\n    {\n        pers_str = NULL;\n    }\n\n    /* set security strength */\n\n    if (sec_strength_bits <= 112) \n    {\n        sec_strength_bits = 112;\n    }\n    else if (sec_strength_bits <= 128)\n    {\n        sec_strength_bits = 128;\n    }\n    else if (sec_strength_bits <= 192) \n    {\n        sec_strength_bits = 192;\n    } \n    else \n    {\n        sec_strength_bits = 256;\n    }\n\n    /* get an uninstantiated drbg */\n\n    if ((drbg = drbg_get_new_drbg()) == NULL)\n    {\n        DRBG_RET(DRBG_NOT_AVAILABLE);\n    }\n    \n    /* init entropy function */\n\n    if (entropy_fn(INIT, NULL) == 0)\n    {\n        DRBG_RET(DRBG_ENTROPY_FAIL);\n    }\n    \n    /* instantiate a SHA-256 HMAC_DRBG */\n\n    if ((result = sha256_hmac_drbg_instantiate(sec_strength_bits,\n                                               pers_str, pers_str_bytes,\n                                               entropy_fn,\n                                               &state)) != DRBG_OK)\n    {\n        return result;\n    }\n    \n    /* init drbg state */\n\n    drbg->handle = drbg_get_new_handle();\n    drbg->type = SHA256_HMAC_DRBG;\n    drbg->state = state;\n\n    /* return drbg handle */\n\n    *handle = drbg->handle;\n    DRBG_RET(DRBG_OK);\n} \n\n\n/* ntru_crypto_drbg_external_instantiate\n *\n * This routine instruments an external DRBG so that ntru_crypto routines\n * can call it. randombytesfn must be of type\n * uint32_t (randombytesfn*)(unsigned char *out, unsigned long long num_bytes);\n * and should return DRBG_OK on success.\n *\n * Returns DRBG_OK if successful.\n * Returns DRBG_ERROR_BASE + DRBG_NOT_AVAILABLE if there are no instantiation\n *  slots available\n * Returns DRBG_ERROR_BASE + DRBG_OUT_OF_MEMORY if the internal state cannot be\n *  allocated from the heap.\n */\n\nuint32_t\nntru_crypto_drbg_external_instantiate(\n    RANDOM_BYTES_FN  randombytesfn, /*  in - pointer to random bytes function */\n    DRBG_HANDLE     *handle)        /* out - address for drbg handle */\n{\n    DRBG_STATE             *drbg = NULL;\n    EXTERNAL_DRBG_STATE    *state = NULL;\n\n    if (!randombytesfn || !handle)\n    {\n        DRBG_RET(DRBG_BAD_PARAMETER);\n    }\n\n    /* get an uninstantiated drbg */\n\n    if ((drbg = drbg_get_new_drbg()) == NULL)\n    {\n        DRBG_RET(DRBG_NOT_AVAILABLE);\n    }\n\n    /* instantiate an External DRBG */\n\n    state = (EXTERNAL_DRBG_STATE*) MALLOC(sizeof(EXTERNAL_DRBG_STATE));\n    if (state == NULL)\n    {\n        DRBG_RET(DRBG_OUT_OF_MEMORY);\n    }\n\n    state->randombytesfn = randombytesfn;\n\n    /* init drbg state */\n\n    drbg->handle = drbg_get_new_handle();\n    drbg->type = EXTERNAL_DRBG;\n    drbg->state = state;\n\n    /* return drbg handle */\n\n    *handle = drbg->handle;\n\n    DRBG_RET(DRBG_OK);\n}\n\n/* ntru_crypto_drbg_uninstantiate\n *\n * This routine frees a drbg given its handle.\n *\n * Returns DRBG_OK if successful.\n * Returns DRBG_ERROR_BASE + DRBG_BAD_PARAMETER if handle is not valid.\n */\n\nuint32_t\nntru_crypto_drbg_uninstantiate(\n    DRBG_HANDLE handle)             /* in - drbg handle */\n{\n    DRBG_STATE *drbg = NULL;\n\n    /* find the instantiated drbg */\n\n    if ((drbg = drbg_get_drbg(handle)) == NULL)\n    {\n        DRBG_RET(DRBG_BAD_PARAMETER);\n    }\n\n    /* zero and free drbg state */\n\n    if (drbg->state) \n    {\n        switch (drbg->type)\n        {\n            case EXTERNAL_DRBG:\n                FREE(drbg->state);\n                break;\n            case SHA256_HMAC_DRBG:\n                sha256_hmac_drbg_free((SHA256_HMAC_DRBG_STATE *)drbg->state);\n                break;\n        }\n        drbg->state = NULL;\n    }\n\n    drbg->handle = 0;\n    DRBG_RET(DRBG_OK);\n}\n\n\n/* ntru_crypto_drbg_reseed\n *\n * This routine reseeds an instantiated drbg.\n * See ANS X9.82: Part 3-2007.\n *\n * Returns DRBG_OK if successful.\n * Returns DRBG_ERROR_BASE + DRBG_BAD_PARAMETER if handle is not valid.\n * Returns HMAC errors if they occur.\n */\n\nuint32_t\nntru_crypto_drbg_reseed(\n    DRBG_HANDLE handle)             /* in - drbg handle */\n{\n    DRBG_STATE *drbg = NULL;\n\n    /* find the instantiated drbg */\n\n    if ((drbg = drbg_get_drbg(handle)) == NULL)\n    {\n        DRBG_RET(DRBG_BAD_PARAMETER);\n    }\n\n    if (drbg->type == EXTERNAL_DRBG)\n    {\n        DRBG_RET(DRBG_BAD_PARAMETER);\n    }\n\n    /* reseed the SHA-256 HMAC_DRBG */\n\n    return sha256_hmac_drbg_reseed((SHA256_HMAC_DRBG_STATE *)drbg->state);\n}\n\n\n/* ntru_crypto_drbg_generate\n *\n * This routine generates pseudorandom bytes using an instantiated drbg.\n * If the maximum number of requests has been reached, reseeding will occur.\n * See ANS X9.82: Part 3-2007.\n *\n * Returns DRBG_OK if successful.\n * Returns DRBG_ERROR_BASE + DRBG_BAD_PARAMETER if handle is not valid or if\n *  an argument pointer is NULL.\n * Returns DRBG_ERROR_BASE + DRBG_BAD_LENGTH if the security strength requested\n *  is too large or the number of bytes requested is zero or too large.\n * Returns HMAC errors if they occur.\n */\n\nuint32_t\nntru_crypto_drbg_generate(\n    DRBG_HANDLE handle,             /*  in - drbg handle */\n    uint32_t    sec_strength_bits,  /*  in - requested sec strength in bits */\n    uint32_t    num_bytes,          /*  in - number of octets to generate */\n    uint8_t    *out)                /* out - address for generated octets */\n{\n    DRBG_STATE *drbg = NULL;\n\n    /* find the instantiated drbg */\n\n    if ((drbg = drbg_get_drbg(handle)) == NULL)\n    {\n       DRBG_RET(DRBG_BAD_PARAMETER);\n    }\n    \n    /* check arguments */\n\n    if (!out)\n    {\n        DRBG_RET(DRBG_BAD_PARAMETER);\n    }\n    \n    if (num_bytes == 0)\n    {\n         DRBG_RET(DRBG_BAD_LENGTH);\n    }\n    \n    /* generate pseudorandom output from the SHA256_HMAC_DRBG */\n\n    switch (drbg->type)\n    {\n        case EXTERNAL_DRBG:\n            return ((EXTERNAL_DRBG_STATE *)drbg->state)->randombytesfn(out,\n                                                                     num_bytes);\n        case SHA256_HMAC_DRBG:\n            return sha256_hmac_drbg_generate(\n                                    (SHA256_HMAC_DRBG_STATE *)drbg->state,\n                                     sec_strength_bits, num_bytes, out);\n        default:\n            DRBG_RET(DRBG_BAD_PARAMETER);\n    }\n}\n\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_hash.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File: ntru_crypto_hash.c\n *\n * Contents: Routines implementing the hash object abstraction.\n *\n *****************************************************************************/\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_hash.h\"\n\ntypedef uint32_t (*NTRU_CRYPTO_HASH_INIT_FN)(\n    void        *c);\ntypedef uint32_t (*NTRU_CRYPTO_HASH_UPDATE_FN)(\n    void        *c,\n    void const  *data,\n    uint32_t     len);\ntypedef uint32_t (*NTRU_CRYPTO_HASH_FINAL_FN)(\n    void        *c,\n    void        *md);\ntypedef uint32_t (*NTRU_CRYPTO_HASH_DIGEST_FN)(\n    void const  *data,\n    uint32_t     len,\n    void        *md);\n\ntypedef struct _NTRU_CRYPTO_HASH_ALG_PARAMS {\n    uint8_t                     algid;\n    uint16_t                    block_length;\n    uint16_t                    digest_length;\n    NTRU_CRYPTO_HASH_INIT_FN    init;\n    NTRU_CRYPTO_HASH_UPDATE_FN  update;\n    NTRU_CRYPTO_HASH_FINAL_FN   final;\n    NTRU_CRYPTO_HASH_DIGEST_FN  digest;\n} NTRU_CRYPTO_HASH_ALG_PARAMS;\n\nstatic NTRU_CRYPTO_HASH_ALG_PARAMS const algs_params[] = {\n    {\n        NTRU_CRYPTO_HASH_ALGID_SHA1,\n        SHA_1_BLK_LEN,\n        SHA_1_MD_LEN,\n        (NTRU_CRYPTO_HASH_INIT_FN) SHA_1_INIT_FN,\n        (NTRU_CRYPTO_HASH_UPDATE_FN) SHA_1_UPDATE_FN,\n        (NTRU_CRYPTO_HASH_FINAL_FN) SHA_1_FINAL_FN,\n        (NTRU_CRYPTO_HASH_DIGEST_FN) SHA_1_DIGEST_FN,\n    },\n    {\n        NTRU_CRYPTO_HASH_ALGID_SHA256,\n        SHA_256_BLK_LEN,\n        SHA_256_MD_LEN,\n        (NTRU_CRYPTO_HASH_INIT_FN) SHA_256_INIT_FN,\n        (NTRU_CRYPTO_HASH_UPDATE_FN) SHA_256_UPDATE_FN,\n        (NTRU_CRYPTO_HASH_FINAL_FN) SHA_256_FINAL_FN,\n        (NTRU_CRYPTO_HASH_DIGEST_FN) SHA_256_DIGEST_FN,\n    },\n};\n\nstatic int const numalgs = (sizeof(algs_params)/sizeof(algs_params[0]));\n\n\n/* get_alg_params\n *\n * Return a pointer to the hash algorithm parameters for the hash algorithm\n * specified, by looking for algid in the global algs_params table.\n * If not found, return NULL.\n */\nstatic NTRU_CRYPTO_HASH_ALG_PARAMS const *\nget_alg_params(\n    NTRU_CRYPTO_HASH_ALGID algid)        /*  in - the hash algorithm to find */\n{\n    int i;\n\n    for (i = 0; i < numalgs; i++)\n    {\n        if (algs_params[i].algid == algid)\n        {\n            return &algs_params[i];\n        }\n    }\n\n    return NULL;\n}\n\n\n/* ntru_crypto_hash_set_alg\n *\n * Sets the hash algorithm for the hash context.  This must be called before\n * any calls to ntru_crypto_hash_block_length(),\n * ntru_crypto_hash_digest_length(), or ntru_crypto_hash_init() are made.\n *\n * Returns NTRU_CRYPTO_HASH_OK on success.\n * Returns NTRU_CRYPTO_HASH_BAD_ALG if the specified algorithm is not supported.\n */\n\nuint32_t\nntru_crypto_hash_set_alg(\n    NTRU_CRYPTO_HASH_ALGID  algid,  /*      in - hash algorithm to be used */\n    NTRU_CRYPTO_HASH_CTX   *c)      /*  in/out - pointer to the hash context */\n{\n    if (!c)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_PARAMETER);\n    }\n    \n    c->alg_params = get_alg_params(algid);\n    \n    if (!c->alg_params) \n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_ALG);\n    }\n\n    HASH_RET(NTRU_CRYPTO_HASH_OK);\n}\n\n\n/* ntru_crypto_hash_block_length\n *\n * Gets the number of bytes in an input block for the hash algorithm\n * specified in the hash context.  The hash algorithm must have been set\n * in the hash context with a call to ntru_crypto_hash_set_alg() prior to\n * calling this function.\n *\n * Returns NTRU_CRYPTO_HASH_OK on success.\n * Returns NTRU_CRYPTO_HASH_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n * Returns NTRU_CRYPTO_HASH_BAD_ALG if the algorithm has not been set.\n */\n\nuint32_t\nntru_crypto_hash_block_length(\n   NTRU_CRYPTO_HASH_CTX *c,         /*  in - pointer to the hash context */\n   uint16_t             *blk_len)   /* out - address for block length in bytes */\n{\n    if (!c || !blk_len)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_PARAMETER);\n    }\n    \n    if (!c->alg_params)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_ALG);\n    }\n    \n    *blk_len = c->alg_params->block_length;\n    HASH_RET(NTRU_CRYPTO_HASH_OK);\n}\n\n\n/* ntru_crypto_hash_digest_length\n *\n * Gets the number of bytes needed to hold the message digest for the\n * hash algorithm specified in the hash context.  The algorithm must have\n * been set in the hash context with a call to ntru_crypto_hash_set_alg() prior\n * to calling this function.\n *\n * Returns NTRU_CRYPTO_HASH_OK on success.\n * Returns NTRU_CRYPTO_HASH_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n * Returns NTRU_CRYPTO_HASH_BAD_ALG if the algorithm has not been set.\n */\n\nuint32_t\nntru_crypto_hash_digest_length(\n   NTRU_CRYPTO_HASH_CTX const *c,      /*  in - pointer to the hash context */\n   uint16_t                   *md_len) /* out - addr for digest length in bytes */\n{\n    if (!c || !md_len)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_PARAMETER);\n    }\n    \n    if (!c->alg_params)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_ALG);\n    }\n    \n    *md_len = c->alg_params->digest_length;\n    HASH_RET(NTRU_CRYPTO_HASH_OK);\n}\n\n\n/* ntru_crypto_hash_init\n *\n * This routine performs standard initialization of the hash state.\n *\n * Returns NTRU_CRYPTO_HASH_OK on success.\n * Returns NTRU_CRYPTO_HASH_FAIL with corrupted context.\n * Returns NTRU_CRYPTO_HASH_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n * Returns NTRU_CRYPTO_HASH_BAD_ALG if the algorithm has not been set.\n */\n\nuint32_t\nntru_crypto_hash_init(\n   NTRU_CRYPTO_HASH_CTX *c)         /* in/out - pointer to hash context */\n{\n    if (!c)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_PARAMETER);\n    }\n    \n    if (!c->alg_params)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_ALG);\n    }\n    \n    return c->alg_params->init(&c->alg_ctx);\n}\n\n\n/* ntru_crypto_hash_update\n *\n * This routine processes input data and updates the hash calculation.\n *\n * Returns NTRU_CRYPTO_HASH_OK on success.\n * Returns NTRU_CRYPTO_HASH_FAIL with corrupted context.\n * Returns NTRU_CRYPTO_HASH_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n * Returns NTRU_CRYPTO_HASH_OVERFLOW if too much text has been fed to the\n *         hash algorithm. The size limit is dependent on the hash algorithm,\n *         and not all algorithms have this limit.\n * Returns NTRU_CRYPTO_HASH_BAD_ALG if the algorithm has not been set.\n */\n\nuint32_t\nntru_crypto_hash_update(\n   NTRU_CRYPTO_HASH_CTX *c,         /* in/out - pointer to hash context */\n   uint8_t const        *data,      /*     in - pointer to input data */\n   uint32_t              data_len)  /*     in - number of bytes of input data */\n{\n    if (!c || (data_len && !data))\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_PARAMETER);\n    }\n    \n    if (!c->alg_params)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_ALG);\n    }\n    \n    return c->alg_params->update(&c->alg_ctx, data, data_len);\n}\n\n\n/* ntru_crypto_hash_final\n *\n * This routine completes the hash calculation and returns the message digest.\n * \n * Returns NTRU_CRYPTO_HASH_OK on success.\n * Returns NTRU_CRYPTO_HASH_FAIL with corrupted context.\n * Returns NTRU_CRYPTO_HASH_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n * Returns NTRU_CRYPTO_HASH_BAD_ALG if the algorithm has not been set.\n */\n\nuint32_t\nntru_crypto_hash_final(\n   NTRU_CRYPTO_HASH_CTX *c,         /* in/out - pointer to hash context */\n   uint8_t              *md)        /*   out  - address for message digest */\n{\n    if (!c || !md)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_PARAMETER);\n    }\n    \n    if (!c->alg_params)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_ALG);\n    }\n    \n    return c->alg_params->final(&c->alg_ctx, md);\n}\n\n\n/* ntru_crypto_hash_digest\n *\n * This routine computes a message digest. It is assumed that the\n * output buffer md is large enough to hold the output (see\n * ntru_crypto_hash_digest_length)\n *\n * Returns NTRU_CRYPTO_HASH_OK on success.\n * Returns NTRU_CRYPTO_HASH_FAIL with corrupted context.\n * Returns NTRU_CRYPTO_HASH_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n * Returns NTRU_CRYPTO_HASH_OVERFLOW if too much text has been fed to the\n *         hash algorithm. The size limit is dependent on the hash algorithm,\n *         and not all algorithms have this limit.\n * Returns NTRU_CRYPTO_HASH_BAD_ALG if the specified algorithm is not supported.\n */\n\nuint32_t\nntru_crypto_hash_digest(\n   NTRU_CRYPTO_HASH_ALGID  algid,    /*  in - the hash algorithm to use */\n   uint8_t const          *data,     /*  in - pointer to input data */\n   uint32_t                data_len, /*  in - number of bytes of input data */\n   uint8_t                *md)       /* out - address for message digest */\n{\n    NTRU_CRYPTO_HASH_ALG_PARAMS const *alg_params = get_alg_params(algid);\n\n    if (!alg_params)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_ALG);\n    }\n    \n    if ((data_len && !data) || !md)\n    {\n        HASH_RET(NTRU_CRYPTO_HASH_BAD_PARAMETER);\n    }\n    \n    return alg_params->digest(data, data_len, md);\n}\n\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_hmac.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File: ntru_crypto_hmac.c\n *\n * Contents: Routines implementing the HMAC hash calculation.\n *\n *****************************************************************************/\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_hmac.h\"\n\n\n/* HMAC context */\n\nstruct _NTRU_CRYPTO_HMAC_CTX {\n    NTRU_CRYPTO_HASH_CTX  hash_ctx;\n    uint8_t              *k0;\n    uint16_t              blk_len;\n    uint16_t              md_len;\n};\n\n\n/* ntru_crypto_hmac_create_ctx\n *\n * This routine creates an HMAC context, setting the hash algorithm and\n * the key to be used.\n *\n * Returns NTRU_CRYPTO_HMAC_OK if successful.\n * Returns NTRU_CRYPTO_HMAC_BAD_ALG if the specified algorithm is not supported.\n * Returns NTRU_CRYPTO_HMAC_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n * Returns NTRU_CRYPTO_HMAC_OUT_OF_MEMORY if memory cannot be allocated.\n */\n\nuint32_t\nntru_crypto_hmac_create_ctx(\n    NTRU_CRYPTO_HASH_ALGID   algid,   /*  in - the hash algorithm to be used */\n    uint8_t const           *key,     /*  in - pointer to the HMAC key */\n    uint32_t                 key_len, /*  in - number of bytes in HMAC key */\n    NTRU_CRYPTO_HMAC_CTX   **c)       /* out - address for pointer to HMAC\n                                               context */\n{\n    NTRU_CRYPTO_HMAC_CTX *ctx = NULL;\n    uint32_t              result;\n\n    /* check parameters */\n\n    if (!c || !key)\n    {\n        HMAC_RET(NTRU_CRYPTO_HMAC_BAD_PARAMETER);\n    }\n    \n    *c = NULL;\n\n    /* allocate memory for an HMAC context */\n    if (NULL == (ctx = (NTRU_CRYPTO_HMAC_CTX*) MALLOC(sizeof(NTRU_CRYPTO_HMAC_CTX))))\n    {\n        HMAC_RET(NTRU_CRYPTO_HMAC_OUT_OF_MEMORY);\n    }\n\n    /* set the algorithm */\n\n    if ((result = ntru_crypto_hash_set_alg(algid, &ctx->hash_ctx))) \n    {\n        FREE(ctx);\n        HMAC_RET(NTRU_CRYPTO_HMAC_BAD_ALG);\n    }\n\n    /* set block length and digest length */\n\n    if ((result = ntru_crypto_hash_block_length(&ctx->hash_ctx,\n                                                &ctx->blk_len))  ||\n        (result = ntru_crypto_hash_digest_length(&ctx->hash_ctx,\n                                                 &ctx->md_len)))\n    {\n        FREE(ctx);\n        return result;\n    }\n\n    /* allocate memory for K0 */\n    if ((ctx->k0 = (uint8_t*) MALLOC(ctx->blk_len)) == NULL) \n    {\n        FREE(ctx);\n        HMAC_RET(NTRU_CRYPTO_HMAC_OUT_OF_MEMORY);\n    }\n\n    /* calculate K0 and store in HMAC context */\n\n    memset(ctx->k0, 0, ctx->blk_len);\n\n    /* check if key is too large */\n\n    if (key_len > ctx->blk_len) \n    {\n        if ((result = ntru_crypto_hash_digest(algid, key, key_len, ctx->k0))) \n        {\n            memset(ctx->k0, 0, ctx->blk_len);\n            FREE(ctx->k0);\n            FREE(ctx);\n            return result;\n        }\n    } \n    else \n    {\n        memcpy(ctx->k0, key, key_len);\n    }\n\n    /* return pointer to HMAC context */\n\n    *c = ctx;\n    HMAC_RET(NTRU_CRYPTO_HMAC_OK);\n}\n\n\n/* ntru_crypto_hmac_destroy_ctx\n *\n * Destroys an HMAC context.\n *\n * Returns NTRU_CRYPTO_HMAC_OK if successful.\n * Returns NTRU_CRYPTO_HMAC_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n */\n\nuint32_t\nntru_crypto_hmac_destroy_ctx(\n    NTRU_CRYPTO_HMAC_CTX *c)        /* in/out - pointer to HMAC context */\n{\n    if (!c || !c->k0)\n    {\n        HMAC_RET(NTRU_CRYPTO_HMAC_BAD_PARAMETER);\n    }\n    \n    /* clear key and release memory */\n\n    memset(c->k0, 0, c->blk_len);\n    FREE(c->k0);\n    FREE(c);\n    \n    HMAC_RET(NTRU_CRYPTO_HMAC_OK);\n}\n\n\n/* ntru_crypto_hmac_get_md_len\n *\n * This routine gets the digest length of the HMAC.\n *\n * Returns NTRU_CRYPTO_HMAC_OK on success.\n * Returns NTRU_CRYPTO_HMAC_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n */\n\nuint32_t\nntru_crypto_hmac_get_md_len(\n    NTRU_CRYPTO_HMAC_CTX const *c,       /*  in - pointer to HMAC context */\n    uint16_t                   *md_len)  /* out - address for digest length */\n{\n    /* check parameters */\n\n    if (!c || !md_len)\n    {\n        HMAC_RET(NTRU_CRYPTO_HMAC_BAD_PARAMETER);\n    }\n    \n    /* get digest length */\n\n    *md_len = c->md_len;\n    HMAC_RET(NTRU_CRYPTO_HMAC_OK);\n}\n\n\n/* ntru_crypto_hmac_set_key\n *\n * This routine sets a digest-length key into the HMAC context.\n *\n * Returns NTRU_CRYPTO_HMAC_OK on success.\n * Returns NTRU_CRYPTO_HMAC_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n */\n\nuint32_t\nntru_crypto_hmac_set_key(\n    NTRU_CRYPTO_HMAC_CTX *c,        /*  in - pointer to HMAC context */\n    uint8_t const        *key)      /*  in - pointer to new HMAC key */\n{\n    /* check parameters */\n\n    if (!c || !key)\n    {\n        HMAC_RET(NTRU_CRYPTO_HMAC_BAD_PARAMETER);\n    }\n    \n    /* copy key */\n\n    memcpy(c->k0, key, c->md_len);\n    HMAC_RET(NTRU_CRYPTO_HMAC_OK);\n}\n\n\n/* ntru_crypto_hmac_init\n *\n * This routine performs standard initialization of the HMAC state.\n *\n * Returns NTRU_CRYPTO_HMAC_OK on success.\n * Returns NTRU_CRYPTO_HASH_FAIL with corrupted context.\n * Returns NTRU_CRYPTO_HMAC_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n */\n\nuint32_t\nntru_crypto_hmac_init(\n    NTRU_CRYPTO_HMAC_CTX *c)        /* in/out - pointer to HMAC context */\n{\n    uint32_t    result;\n    int         i;\n\n    /* check parameters */\n\n    if (!c)\n    {\n        HMAC_RET(NTRU_CRYPTO_HMAC_BAD_PARAMETER);\n    }\n    \n    /* init hash context and compute H(K0 ^ ipad) */\n\n    for (i = 0; i < c->blk_len; i++)\n    {\n        c->k0[i] ^= 0x36;                           /* K0 ^ ipad */\n    }\n        \n    if ((result = ntru_crypto_hash_init(&c->hash_ctx))                   ||\n        (result = ntru_crypto_hash_update(&c->hash_ctx, c->k0, c->blk_len)))\n    {\n        return result;\n    }\n    \n    HMAC_RET(NTRU_CRYPTO_HMAC_OK);\n}\n\n\n/* ntru_crypto_hmac_update\n *\n * This routine processes input data and updates the HMAC hash calculation.\n *\n * Returns NTRU_CRYPTO_HMAC_OK on success.\n * Returns NTRU_CRYPTO_HASH_FAIL with corrupted context.\n * Returns NTRU_CRYPTO_HMAC_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n * Returns NTRU_CRYPTO_HASH_OVERFLOW if more than bytes are hashed than the\n *         underlying hash algorithm can handle.\n */\n\nuint32_t\nntru_crypto_hmac_update(\n    NTRU_CRYPTO_HMAC_CTX *c,         /* in/out - pointer to HMAC context */\n    const uint8_t        *data,      /*     in - pointer to input data */\n    uint32_t              data_len)  /*     in - no. of bytes of input data */\n{\n    uint32_t    result;\n\n    /* check parameters */\n\n    if (!c || (data_len && !data))\n    {\n        HMAC_RET(NTRU_CRYPTO_HMAC_BAD_PARAMETER);\n    }\n    \n    if ((result = ntru_crypto_hash_update(&c->hash_ctx, data, data_len)))\n    {\n        return result;\n    }\n    \n    HMAC_RET(NTRU_CRYPTO_HMAC_OK);\n}\n\n\n/* ntru_crypto_hmac_final\n *\n * This routine completes the HMAC hash calculation and returns the\n * message digest.\n *\n * Returns NTRU_CRYPTO_HMAC_OK on success.\n * Returns NTRU_CRYPTO_HASH_FAIL with corrupted context.\n * Returns NTRU_CRYPTO_HMAC_BAD_PARAMETER if inappropriate NULL pointers are\n * passed.\n */\n\nuint32_t\nntru_crypto_hmac_final(\n    NTRU_CRYPTO_HMAC_CTX *c,        /* in/out - pointer to HMAC context */\n    uint8_t              *md)       /*   out - address for message digest */\n{\n    uint32_t    result = NTRU_CRYPTO_HMAC_OK;\n    int         i;\n\n    /* check parameters */\n\n    if (!c || !md)\n    {\n        HMAC_RET(NTRU_CRYPTO_HMAC_BAD_PARAMETER);\n    }\n    \n    /* form K0 ^ opad\n     * complete md = H((K0 ^ ipad) || data)\n     * compute  md = H((K0 ^ opad) || md)\n     * re-form K0\n     */\n\n    for (i = 0; i < c->blk_len; i++)\n    {\n        c->k0[i] ^= (0x36^0x5c);\n    }\n        \n    if ((result = ntru_crypto_hash_final(&c->hash_ctx, md))                  ||\n        (result = ntru_crypto_hash_init(&c->hash_ctx))                       ||\n        (result = ntru_crypto_hash_update(&c->hash_ctx, c->k0, c->blk_len))  ||\n        (result = ntru_crypto_hash_update(&c->hash_ctx, md, c->md_len))      ||\n        (result = ntru_crypto_hash_final(&c->hash_ctx, md))) \n    {\n    }\n    \n    for (i = 0; i < c->blk_len; i++)\n    {\n        c->k0[i] ^= 0x5c;\n    }\n    \n    return result;\n}\n\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_mbyte_uint32.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File: ntru_crypto_msbyte_uint32.c\n *\n * Contents: Routines to convert between an array of bytes in network byte\n *           order (most-significant byte first) and an array of uint32 words.\n *\n *****************************************************************************/\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_msbyte_uint32.h\"\n\n\n/* ntru_crypto_msbyte_2_uint32()\n *\n * This routine converts an array of bytes in network byte order to an array\n * of uint32_t, placing the first byte in the most significant byte of the\n * first uint32_t word.\n *\n * The number of bytes in the input stream MUST be at least 4 times the\n * number of words expected in the output array.\n */\n\nvoid\nntru_crypto_msbyte_2_uint32(\n    uint32_t       *words,      /* out - pointer to the output uint32_t array */\n    uint8_t const  *bytes,      /*  in - pointer to the input byte array */\n    uint32_t        n)          /*  in - number of words in the output array */\n{\n    uint32_t    i;\n\n    for (i = 0; i < n; i++) \n    {\n        words[i]  = ((uint32_t) (*bytes++)) << 24;\n        words[i] |= ((uint32_t) (*bytes++)) << 16;\n        words[i] |= ((uint32_t) (*bytes++)) <<  8;\n        words[i] |=  (uint32_t) (*bytes++);\n    }\n    \n    return;\n}\n\n\n/* ntru_crypto_uint32_2_msbyte()\n *\n * This routine converts an array of uint32_t to an array of bytes in\n * network byte order, placing the most significant byte of the first uint32_t\n * word as the first byte of the output array.\n *\n * The number of bytes in the output stream will be 4 times the number of words\n * specified in the input array.\n */\n\nvoid\nntru_crypto_uint32_2_msbyte(\n    uint8_t        *bytes,      /* out - pointer to the output byte array */\n    uint32_t const *words,      /*  in - pointer to the input uint32_t array */\n    uint32_t        n)          /*  in - number of words in the input array */\n{\n    uint32_t i;\n\n    for (i = 0; i < n; i++) \n    {\n        *bytes++ = (uint8_t) (words[i] >> 24);\n        *bytes++ = (uint8_t) (words[i] >> 16);\n        *bytes++ = (uint8_t) (words[i] >>  8);\n        *bytes++ = (uint8_t) (words[i]      );\n    }\n    \n    return;\n}\n\n\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_ntru_convert.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File: ntru_crypto_ntru_convert.c\n *\n * Contents: Conversion routines for NTRUEncrypt, including packing, unpacking,\n *           and others.\n *\n *****************************************************************************/\n\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_ntru_convert.h\"\n\n\n/* 3-bit to 2-trit conversion tables: 2 represents -1 */\n\nstatic uint8_t const bits_2_trit1[] = {0, 0, 0, 1, 1, 1, 2, 2};\nstatic uint8_t const bits_2_trit2[] = {0, 1, 2, 0, 1, 2, 0, 1};\n\n\n/* ntru_bits_2_trits\n *\n * Each 3 bits in an array of octets is converted to 2 trits in an array\n * of trits.\n *\n * The octet array may overlap the end of the trit array.\n */\n\nvoid\nntru_bits_2_trits(\n    uint8_t const *octets,          /*  in - pointer to array of octets */\n    uint16_t       num_trits,       /*  in - number of trits to produce */\n    uint8_t       *trits)           /* out - address for array of trits */\n{\n    uint32_t bits24;\n    uint32_t bits3;\n    uint32_t shift;\n\n    while (num_trits >= 16) \n    {\n        /* get next three octets */\n\n        bits24  = ((uint32_t)(*octets++)) << 16;\n        bits24 |= ((uint32_t)(*octets++)) <<  8;\n        bits24 |=  (uint32_t)(*octets++);\n\n        /* for each 3 bits in the three octets, output 2 trits */\n\n        bits3 = (bits24 >> 21) & 0x7;\n        *trits++ = bits_2_trit1[bits3];\n        *trits++ = bits_2_trit2[bits3];\n\n        bits3 = (bits24 >> 18) & 0x7;\n        *trits++ = bits_2_trit1[bits3];\n        *trits++ = bits_2_trit2[bits3];\n\n        bits3 = (bits24 >> 15) & 0x7;\n        *trits++ = bits_2_trit1[bits3];\n        *trits++ = bits_2_trit2[bits3];\n\n        bits3 = (bits24 >> 12) & 0x7;\n        *trits++ = bits_2_trit1[bits3];\n        *trits++ = bits_2_trit2[bits3];\n\n        bits3 = (bits24 >>  9) & 0x7;\n        *trits++ = bits_2_trit1[bits3];\n        *trits++ = bits_2_trit2[bits3];\n\n        bits3 = (bits24 >>  6) & 0x7;\n        *trits++ = bits_2_trit1[bits3];\n        *trits++ = bits_2_trit2[bits3];\n\n        bits3 = (bits24 >>  3) & 0x7;\n        *trits++ = bits_2_trit1[bits3];\n        *trits++ = bits_2_trit2[bits3];\n\n        bits3 = bits24 & 0x7;\n        *trits++ = bits_2_trit1[bits3];\n        *trits++ = bits_2_trit2[bits3];\n\n        num_trits -= 16;\n    }\n    \n    if (num_trits == 0)\n    {\n        return;\n    }\n\n    /* get three octets */\n\n    bits24  = ((uint32_t)(*octets++)) << 16;\n    bits24 |= ((uint32_t)(*octets++)) <<  8;\n    bits24 |=  (uint32_t)(*octets++);\n\n    shift = 21;\n    while (num_trits) \n    {\n        /* for each 3 bits in the three octets, output up to 2 trits\n         * until all trits needed are produced\n         */\n\n        bits3 = (bits24 >> shift) & 0x7;\n        shift -= 3;\n        *trits++ = bits_2_trit1[bits3];\n        \n        if (--num_trits) \n        {\n            *trits++ = bits_2_trit2[bits3];\n            --num_trits;\n        }\n    }\n    \n    return;\n}\n\n\n/* ntru_trits_2_bits\n *\n * Each 2 trits in an array of trits is converted to 3 bits, and the bits\n * are packed in an array of octets.  A multiple of 3 octets is output.\n * Any bits in the final octets not derived from trits are zero.\n *\n * Returns TRUE if all trits were valid.\n * Returns FALSE if invalid trits were found.\n */\n\nbool\nntru_trits_2_bits(\n    uint8_t const *trits,           /*  in - pointer to array of trits */\n    uint32_t       num_trits,       /*  in - number of trits to convert */\n    uint8_t       *octets)          /* out - address for array of octets */\n{\n    bool     all_trits_valid = TRUE;\n    uint32_t bits24;\n    uint32_t bits3;\n    uint32_t shift;\n\n    while (num_trits >= 16) \n    {\n\n        /* convert each 2 trits to 3 bits and pack */\n\n        bits3  = *trits++ * 3;\n        bits3 += *trits++;\n        \n        if (bits3 > 7) \n        {\n            bits3 = 7;\n            all_trits_valid = FALSE;\n        }\n        \n        bits24 = (bits3 << 21);\n        bits3  = *trits++ * 3;\n        bits3 += *trits++;\n        \n        if (bits3 > 7) \n        {\n            bits3 = 7;\n            all_trits_valid = FALSE;\n        }\n        \n        bits24 |= (bits3 << 18);\n        bits3  = *trits++ * 3;\n        bits3 += *trits++;\n        \n        if (bits3 > 7) \n        {\n            bits3 = 7;\n            all_trits_valid = FALSE;\n        }\n        \n        bits24 |= (bits3 << 15);\n        bits3  = *trits++ * 3;\n        bits3 += *trits++;\n        \n        if (bits3 > 7)\n        {\n            bits3 = 7;\n            all_trits_valid = FALSE;\n        }\n        \n        bits24 |= (bits3 << 12);\n        bits3  = *trits++ * 3;\n        bits3 += *trits++;\n        \n        if (bits3 > 7) \n        {\n            bits3 = 7;\n            all_trits_valid = FALSE;\n        }\n        \n        bits24 |= (bits3 <<  9);\n        bits3  = *trits++ * 3;\n        bits3 += *trits++;\n        \n        if (bits3 > 7) \n        {\n            bits3 = 7;\n            all_trits_valid = FALSE;\n        }\n        \n        bits24 |= (bits3 <<  6);\n        bits3  = *trits++ * 3;\n        bits3 += *trits++;\n        \n        if (bits3 > 7) \n        {\n            bits3 = 7;\n            all_trits_valid = FALSE;\n        }\n        \n        bits24 |= (bits3 <<  3);\n        bits3  = *trits++ * 3;\n        bits3 += *trits++;\n        \n        if (bits3 > 7) \n        {\n            bits3 = 7;\n            all_trits_valid = FALSE;\n        }\n        \n        bits24 |= bits3;\n        num_trits -= 16;\n\n        /* output three octets */\n\n        *octets++ = (uint8_t)((bits24 >> 16) & 0xff);\n        *octets++ = (uint8_t)((bits24 >>  8) & 0xff);\n        *octets++ = (uint8_t)(bits24 & 0xff);\n    }\n\n    bits24 = 0;\n    shift = 21;\n    \n    while (num_trits) \n    {\n\n        /* convert each 2 trits to 3 bits and pack */\n\n        bits3 = *trits++ * 3;\n        \n        if (--num_trits) \n        {\n            bits3 += *trits++;\n            --num_trits;\n        }\n        \n        if (bits3 > 7) \n        {\n            bits3 = 7;\n            all_trits_valid = FALSE;\n        }\n        \n        bits24 |= (bits3 << shift);\n        shift -= 3;\n    }\n\n    /* output three octets */\n\n    *octets++ = (uint8_t)((bits24 >> 16) & 0xff);\n    *octets++ = (uint8_t)((bits24 >>  8) & 0xff);\n    *octets++ = (uint8_t)(bits24 & 0xff);\n\n    return all_trits_valid;\n}\n\n\n/* ntru_coeffs_mod4_2_octets\n *\n * Takes an array of ring element coefficients mod 4 and packs the\n * results into an octet string.\n */\n\nvoid\nntru_coeffs_mod4_2_octets(\n    uint16_t        num_coeffs,     /*  in - number of coefficients */\n    uint16_t const *coeffs,         /*  in - pointer to coefficients */\n    uint8_t        *octets)         /* out - address for octets */\n{\n    uint8_t  bits2;\n    int      shift;\n    uint16_t i;\n\n    *octets = 0;\n    shift = 6;\n    for (i = 0; i < num_coeffs; i++) \n    {\n        bits2 = (uint8_t)(coeffs[i] & 0x3);\n        *octets |= bits2 << shift;\n        shift -= 2;\n        \n        if (shift < 0) \n        {\n            ++octets;\n            *octets = 0;\n            shift = 6;\n        }\n    }\n    \n    return;\n}\n\n\n/* ntru_trits_2_octet\n *\n * Packs 5 trits in an octet, where a trit is 0, 1, or 2 (-1).\n */\n\nvoid\nntru_trits_2_octet(\n    uint8_t const *trits,           /*  in - pointer to trits */\n    uint8_t *octet)                 /* out - address for octet */\n{\n    int i;\n\n    *octet = 0;\n    for (i = 4; i >= 0; i--) \n    {\n        *octet = (*octet * 3) + trits[i];\n    }\n    \n    return;\n}\n\n\n/* ntru_octet_2_trits\n *\n * Unpacks an octet to 5 trits, where a trit is 0, 1, or 2 (-1).\n */\n\nvoid\nntru_octet_2_trits(\n    uint8_t  octet,                 /*  in - octet to be unpacked */\n    uint8_t *trits)                 /* out - address for trits */\n{\n    int i;\n\n    for (i = 0; i < 5; i++) \n    {\n        trits[i] = octet % 3;\n        octet = (octet - trits[i]) / 3;\n    }\n    \n    return;\n}\n\n\n/* ntru_indices_2_trits\n *\n * Converts a list of the nonzero indices of a polynomial into an array of\n * trits.\n */\n\nvoid\nntru_indices_2_trits(\n    uint16_t        in_len,         /*  in - no. of indices */\n    uint16_t const *in,             /*  in - pointer to list of indices */\n    bool            plus1,          /*  in - if list is +1 cofficients */\n    uint8_t        *out)            /* out - address of output polynomial */\n{\n    uint8_t     trit = plus1 ? 1 : 2;\n    uint16_t    i;\n    \n    for (i = 0; i < in_len; i++) \n    {\n        out[in[i]] = trit;\n    }\n    \n    return;\n}\n\n\n/* ntru_packed_trits_2_indices\n *\n * Unpacks an array of N trits and creates a list of array indices \n * corresponding to trits = +1, and list of array indices corresponding to\n * trits = -1.\n */\n\nvoid\nntru_packed_trits_2_indices(\n    uint8_t const *in,              /*  in - pointer to packed-trit octets */\n    uint16_t       num_trits,       /*  in - no. of packed trits */\n    uint16_t      *indices_plus1,   /* out - address for indices of +1 trits */\n    uint16_t      *indices_minus1)  /* out - address for indices of -1 trits */\n{\n    uint8_t  trits[5];\n    uint16_t i = 0;\n    int      j;\n\n    while (num_trits >= 5)\n    {\n        ntru_octet_2_trits(*in++, trits);\n        num_trits -= 5;\n        \n        for (j = 0; j < 5; j++, i++) \n        {\n            if (trits[j] == 1) \n            {\n                *indices_plus1 = i;\n                ++indices_plus1;\n            } \n            else if (trits[j] == 2) \n            {\n                *indices_minus1 = i;\n                ++indices_minus1;\n            }\n            else\n            {\n                ;\n            }\n        }\n    }\n    \n    if (num_trits) \n    {\n        ntru_octet_2_trits(*in, trits);\n        \n        for (j = 0; num_trits && (j < 5); j++, i++) \n        {\n            if (trits[j] == 1) \n            {\n                *indices_plus1 = i;\n                ++indices_plus1;\n            }\n            else if (trits[j] == 2) \n            {\n                *indices_minus1 = i;\n                ++indices_minus1;\n            }\n            else\n            {\n                ;\n            }\n            \n            --num_trits;\n        }\n    }\n    \n    return;\n}\n\n\n/* ntru_indices_2_packed_trits\n *\n * Takes a list of array indices corresponding to elements whose values\n * are +1 or -1, and packs the N-element array of trits described by these\n * lists into octets, 5 trits per octet.\n */\n\nvoid\nntru_indices_2_packed_trits(\n    uint16_t const *indices,        /*  in - pointer to indices */\n    uint16_t        num_plus1,      /*  in - no. of indices for +1 trits */\n    uint16_t        num_minus1,     /*  in - no. of indices for -1 trits */\n    uint16_t        num_trits,      /*  in - N, no. of trits in array */\n    uint8_t        *buf,            /*  in - temp buf, N octets */\n    uint8_t        *out)            /* out - address for packed octets */\n{\n    \n    /* convert indices to an array of trits */\n\n    memset(buf, 0, num_trits);\n    ntru_indices_2_trits(num_plus1, indices, TRUE, buf);\n    ntru_indices_2_trits(num_minus1, indices + num_plus1, FALSE, buf);\n\n    /* pack the array of trits */\n\n    while (num_trits >= 5) \n    {\n        ntru_trits_2_octet(buf, out);\n        num_trits -= 5;\n        buf += 5;\n        ++out;\n    }\n    \n    if (num_trits) \n    {\n        uint8_t trits[5];\n\n        memcpy(trits, buf, num_trits);\n        memset(trits + num_trits, 0, sizeof(trits) - num_trits);\n        ntru_trits_2_octet(trits, out);\n    }\n    \n    return;\n}\n\n\n/* ntru_elements_2_octets\n *\n * Packs an array of n-bit elements into an array of\n * ((in_len * n_bits) + 7) / 8 octets.\n * NOTE: Assumes 8 < n_bits < 16.\n */\n\nvoid\nntru_elements_2_octets(\n    uint16_t        in_len,         /*  in - no. of elements to be packed */\n    uint16_t const *in,             /*  in - ptr to elements to be packed */\n    uint8_t         n_bits,         /*  in - no. of bits in input element */\n    uint8_t        *out)            /* out - addr for output octets */\n{\n    uint16_t  temp;\n    uint16_t  shift;\n    uint16_t  i;\n\n    /* pack */\n\n    temp = 0;\n    shift = n_bits - 8;\n    i = 0;\n    while (i < in_len) \n    {\n        /* add bits to temp to fill an octet and output the octet */\n        temp |= in[i] >> shift;\n        *out++ = (uint8_t)(temp & 0xff);\n        if (shift > 8)\n        {\n            /* next full octet is in current input word */\n\n            shift = shift - 8;\n            temp = 0;\n        }\n        else\n        {\n            shift = 8 - shift;\n            /* put remaining bits of input word in temp as partial octet,\n             * and increment index to next input word\n             */\n            temp = in[i] << shift;\n            shift = n_bits - shift;\n\n            ++i;\n        }\n    }\n\n    /* output any bits remaining in last input word */\n\n    if (shift != n_bits - 8) \n    {\n        *out++ = (uint8_t)(temp & 0xff);\n    }\n\n    return;\n}\n\n\n/* ntru_octets_2_elements\n *\n * Unpacks an octet string into an array of ((in_len * 8) / n_bits)\n * n-bit elements.  Any extra bits are discarded.\n * NOTE: Assumes 8 < n_bits < 16.\n */\n\nvoid\nntru_octets_2_elements(\n    uint16_t        in_len,         /*  in - no. of octets to be unpacked */\n    uint8_t const  *in,             /*  in - ptr to octets to be unpacked */\n    uint8_t         n_bits,         /*  in - no. of bits in output element */\n    uint16_t       *out)            /* out - addr for output elements */\n{\n    uint16_t  temp;\n    uint16_t  mask;\n    uint16_t  shift;\n    uint16_t  i;\n\n    /* unpack */\n\n    temp = 0;\n    mask = (1 << n_bits) - 1;\n    shift = n_bits;\n    i = 0;\n\n    while (i < in_len) \n    {\n        if (shift > 8)\n        {\n            /* the current octet will not fill the current element */\n\n            shift = shift - 8;\n            temp |= ((uint16_t)in[i]) << shift;\n        }\n        else\n        {\n            /* add bits from the current octet to fill the current element and\n             * output the element\n             */\n\n            shift = 8 - shift;\n\n            temp |= ((uint16_t)in[i]) >> shift;\n            *out++ = temp & mask;\n\n            /* add the remaining bits of the current octet to start an element */ \n            shift = n_bits - shift;\n            temp = ((uint16_t)in[i]) << shift;\n        }\n        ++i;\n    }\n\n    return;\n}\n\n\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_ntru_encrypt.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File: ntru_crypto_ntru_encrypt.c\n *\n * Contents: Routines implementing NTRUEncrypt encryption and decryption and\n *           key generation.\n *\n *****************************************************************************/\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_ntru_encrypt_param_sets.h\"\n#include \"ntru_crypto_ntru_encrypt_key.h\"\n#include \"ntru_crypto_ntru_convert.h\"\n#include \"ntru_crypto_ntru_poly.h\"\n#include \"ntru_crypto_ntru_mgf1.h\"\n#include \"ntru_crypto_drbg.h\"\n\n\n/* ntru_crypto_ntru_encrypt\n *\n * Implements NTRU encryption (SVES) for the parameter set specified in\n * the public key blob.\n *\n * Before invoking this function, a DRBG must be instantiated using\n * ntru_crypto_drbg_instantiate() to obtain a DRBG handle, and in that\n * instantiation the requested security strength must be at least as large\n * as the security strength of the NTRU parameter set being used.\n * Failure to instantiate the DRBG with the proper security strength will\n * result in this function returning DRBG_ERROR_BASE + DRBG_BAD_LENGTH.\n *\n * The required minimum size of the output ciphertext buffer (ct) may be\n * queried by invoking this function with ct = NULL.  In this case, no\n * encryption is performed, NTRU_OK is returned, and the required minimum\n * size for ct is returned in ct_len.\n *\n * When ct != NULL, at invocation *ct_len must be the size of the ct buffer.\n * Upon return it is the actual size of the ciphertext.\n *\n * Returns NTRU_OK if successful.\n * Returns DRBG_ERROR_BASE + DRBG_BAD_PARAMETER if the DRBG handle is invalid.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_PARAMETER if an argument pointer\n *  (other than ct) is NULL.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_LENGTH if a length argument\n *  (pubkey_blob_len or pt_len) is zero, or if pt_len exceeds the\n *  maximum plaintext length for the parameter set.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_PUBLIC_KEY if the public-key blob is\n *  invalid (unknown format, corrupt, bad length).\n * Returns NTRU_ERROR_BASE + NTRU_BUFFER_TOO_SMALL if the ciphertext buffer\n *  is too small.\n * Returns NTRU_ERROR_BASE + NTRU_NO_MEMORY if memory needed cannot be\n *  allocated from the heap.\n */\n\nuint32_t\nntru_crypto_ntru_encrypt(\n    DRBG_HANDLE     drbg_handle,     /*     in - handle of DRBG */\n    uint16_t        pubkey_blob_len, /*     in - no. of octets in public key\n                                                 blob */\n    uint8_t const  *pubkey_blob,     /*     in - pointer to public key */\n    uint16_t        pt_len,          /*     in - no. of octets in plaintext */\n    uint8_t const  *pt,              /*     in - pointer to plaintext */\n    uint16_t       *ct_len,          /* in/out - no. of octets in ct, addr for\n                                                 no. of octets in ciphertext */\n    uint8_t        *ct)              /*    out - address for ciphertext */\n{\n    NTRU_ENCRYPT_PARAM_SET *params = NULL;\n    uint8_t const          *pubkey_packed = NULL;\n    uint8_t                 pubkey_pack_type = 0x00;\n    uint16_t                packed_ct_len;\n    size_t                  scratch_buf_len;\n    uint32_t                dr;\n    uint32_t                dr1 = 0;\n    uint32_t                dr2 = 0;\n    uint32_t                dr3 = 0;\n    uint16_t                num_scratch_polys;\n    uint16_t                pad_deg;\n    uint16_t                ring_mult_tmp_len;\n    uint16_t               *scratch_buf = NULL;\n    uint16_t               *ringel_buf = NULL;\n    uint16_t               *r_buf = NULL;\n    uint8_t                *b_buf = NULL;\n    uint8_t                *tmp_buf = NULL;\n    bool                    msg_rep_good = FALSE;\n    NTRU_CRYPTO_HASH_ALGID  hash_algid;\n    uint8_t                 md_len;\n    uint16_t                mod_q_mask;\n    uint32_t                result = NTRU_OK;\n\n    /* check for bad parameters */\n\n    if (!pubkey_blob || !ct_len)\n    {\n        NTRU_RET(NTRU_BAD_PARAMETER);\n    }\n\n    if (pubkey_blob_len == 0)\n    {\n        NTRU_RET(NTRU_BAD_LENGTH);\n    }\n\n    /* get a pointer to the parameter-set parameters, the packing type for\n     * the public key, and a pointer to the packed public key\n     */\n\n    if (!ntru_crypto_ntru_encrypt_key_parse(TRUE /* pubkey */, pubkey_blob_len,\n                                            pubkey_blob, &pubkey_pack_type,\n                                            NULL, &params, &pubkey_packed,\n                                            NULL))\n    {\n        NTRU_RET(NTRU_BAD_PUBLIC_KEY);\n    }\n\n    if(params->q_bits <= 8\n            || params->q_bits >= 16\n            || pubkey_pack_type != NTRU_ENCRYPT_KEY_PACKED_COEFFICIENTS)\n    {\n        NTRU_RET(NTRU_UNSUPPORTED_PARAM_SET);\n    }\n\n    /* return the ciphertext size if requested */\n\n    packed_ct_len = (params->N * params->q_bits + 7) >> 3;\n    \n    if (!ct)\n    {\n        *ct_len = packed_ct_len;\n        NTRU_RET(NTRU_OK);\n    }\n\n    /* check the ciphertext buffer size */\n\n    if (*ct_len < packed_ct_len)\n    {\n        NTRU_RET(NTRU_BUFFER_TOO_SMALL);\n    }\n\n    /* check that a plaintext was provided */\n\n    if (!pt)\n    {\n        NTRU_RET(NTRU_BAD_PARAMETER);\n    }\n\n    /* check the plaintext length */\n\n    if (pt_len > params->m_len_max)\n    {\n        NTRU_RET(NTRU_BAD_LENGTH);\n    }\n\n    /* allocate memory for all operations */\n\n    ntru_ring_mult_indices_memreq(params->N, &num_scratch_polys, &pad_deg);\n\n    if (params->is_product_form) {\n        dr1 =  params->dF_r & 0xff;\n        dr2 = (params->dF_r >>  8) & 0xff;\n        dr3 = (params->dF_r >> 16) & 0xff;\n        dr = dr1 + dr2 + dr3;\n        num_scratch_polys += 1; /* mult_product_indices needs space for a\n                                   mult_indices and one intermediate result */\n    }\n    else\n    {\n        dr = params->dF_r;\n    }\n    ring_mult_tmp_len = num_scratch_polys * pad_deg;\n\n    scratch_buf_len = (ring_mult_tmp_len << 1) +\n                                            /* X-byte temp buf for ring mult and\n                                                other intermediate results */\n                      (pad_deg << 1) +      /* 2N-byte buffer for ring elements\n                                                and overflow from temp buffer */\n                      (dr << 2) +           /* buffer for r indices */\n                      params->b_len;\n                                            /* buffer for b */\n    scratch_buf = MALLOC(scratch_buf_len);\n    if (!scratch_buf)\n    {\n        NTRU_RET(NTRU_OUT_OF_MEMORY);\n    }\n\n    ringel_buf = scratch_buf + ring_mult_tmp_len;\n    r_buf = ringel_buf + pad_deg;\n    b_buf = (uint8_t *)(r_buf + (dr << 1));\n    tmp_buf = (uint8_t *)scratch_buf;\n\n    /* set hash algorithm and seed length based on security strength */\n\n    if (params->hash_algid == NTRU_CRYPTO_HASH_ALGID_SHA1)\n    {\n        hash_algid = NTRU_CRYPTO_HASH_ALGID_SHA1;\n        md_len = SHA_1_MD_LEN;\n    }\n    else if (params->hash_algid == NTRU_CRYPTO_HASH_ALGID_SHA256)\n    {\n        hash_algid = NTRU_CRYPTO_HASH_ALGID_SHA256;\n        md_len = SHA_256_MD_LEN;\n    }\n    else\n    {\n        FREE(scratch_buf);\n        NTRU_RET(NTRU_UNSUPPORTED_PARAM_SET);\n    }\n\n    /* set constants */\n\n    mod_q_mask = params->q - 1;\n\n    /* loop until a message representative with proper weight is achieved */\n\n    do {\n        uint8_t *ptr = tmp_buf;\n\n        /* get b */\n        result = ntru_crypto_drbg_generate(drbg_handle,\n                                           params->sec_strength_len << 3,\n                                           params->b_len, b_buf);\n\n        if (result == NTRU_OK)\n        {\n            /* form sData (OID || m || b || hTrunc) */\n\n            memcpy(ptr, params->OID, 3);\n            ptr += 3;\n            memcpy(ptr, pt, pt_len);\n            ptr += pt_len;\n            memcpy(ptr, b_buf, params->b_len);\n            ptr += params->b_len;\n            memcpy(ptr, pubkey_packed, params->sec_strength_len);\n            ptr += params->sec_strength_len;\n\n\n            /* generate r */\n\n            result = ntru_gen_poly(hash_algid, md_len,\n                                   params->min_IGF_hash_calls,\n                                   (uint16_t)(ptr - tmp_buf),\n                                   tmp_buf, tmp_buf,\n                                   params->N, params->c_bits,\n                                   params->no_bias_limit,\n                                   params->is_product_form,\n                                   params->dF_r << 1, r_buf);\n        }\n\n        if (result == NTRU_OK)\n        {\n            uint16_t pubkey_packed_len;\n\n            /* unpack the public key */\n            pubkey_packed_len = (params->N * params->q_bits + 7) >> 3;\n            ntru_octets_2_elements(pubkey_packed_len, pubkey_packed,\n                                   params->q_bits, ringel_buf);\n\n            /* form R = h * r */\n\n            if (params->is_product_form)\n            {\n                ntru_ring_mult_product_indices(ringel_buf, (uint16_t)dr1,\n                                               (uint16_t)dr2, (uint16_t)dr3,\n                                               r_buf, params->N, params->q,\n                                               scratch_buf, ringel_buf);\n            }\n            else\n            {\n                ntru_ring_mult_indices(ringel_buf, (uint16_t)dr, (uint16_t)dr,\n                                       r_buf, params->N, params->q,\n                                       scratch_buf, ringel_buf);\n            }\n\n            /* form R mod 4 */\n\n            ntru_coeffs_mod4_2_octets(params->N, ringel_buf, tmp_buf);\n\n            /* form mask */\n\n            result = ntru_mgftp1(hash_algid, md_len,\n                                 params->min_MGF_hash_calls,\n                                 (params->N + 3) / 4, tmp_buf,\n                                 tmp_buf + params->N, params->N, tmp_buf);\n        }\n\n        if (result == NTRU_OK)\n        {\n            uint8_t  *Mtrin_buf = tmp_buf + params->N;\n            uint8_t  *M_buf = Mtrin_buf + params->N -\n                              (params->b_len + params->m_len_len +\n                               params->m_len_max + 2);\n            uint16_t  i;\n\n            /* form the padded message M */\n\n            ptr = M_buf;\n            memcpy(ptr, b_buf, params->b_len);\n            ptr += params->b_len;\n            if (params->m_len_len == 2)\n                *ptr++ = (uint8_t)((pt_len >> 8) & 0xff);\n            *ptr++ = (uint8_t)(pt_len & 0xff);\n            memcpy(ptr, pt, pt_len);\n            ptr += pt_len;\n\n            /* add an extra zero byte in case without it the bit string\n             * is not a multiple of 3 bits and therefore might not be\n             * able to produce enough trits\n             */\n\n            memset(ptr, 0, params->m_len_max - pt_len + 2);\n\n            /* convert M to trits (Mbin to Mtrin) */\n\n            ntru_bits_2_trits(M_buf, params->N, Mtrin_buf);\n\n            /* form the msg representative m' by adding Mtrin to mask, mod p */\n\n            for (i = 0; i < params->N; i++)\n            {\n                tmp_buf[i] = tmp_buf[i] + Mtrin_buf[i];\n\n                if (tmp_buf[i] >= 3)\n                {\n                    tmp_buf[i] -= 3;\n                }\n            }\n\n            /* check that message representative meets minimum weight\n             * requirements\n             */\n            msg_rep_good = ntru_poly_check_min_weight(params->N, tmp_buf,\n                                                   params->min_msg_rep_wt);\n        }\n    } while ((result == NTRU_OK) && !msg_rep_good);\n\n    if (result == NTRU_OK)\n    {\n        uint16_t i;\n\n        /* form ciphertext e by adding m' to R mod q */\n\n        for (i = 0; i < params->N; i++)\n        {\n            if (tmp_buf[i] == 1)\n            {\n                ringel_buf[i] = (ringel_buf[i] + 1) & mod_q_mask;\n            }\n            else if (tmp_buf[i] == 2)\n            {\n                ringel_buf[i] = (ringel_buf[i] - 1) & mod_q_mask;\n            }\n            else\n            {\n                ;\n            }\n        }\n\n        /* pack ciphertext */\n\n        ntru_elements_2_octets(params->N, ringel_buf, params->q_bits, ct);\n        *ct_len = packed_ct_len;\n    }\n\n    /* cleanup */\n\n    memset(scratch_buf, 0, scratch_buf_len);\n    FREE(scratch_buf);\n\n    return result;\n}\n\n\n/* ntru_crypto_ntru_decrypt\n *\n * Implements NTRU decryption (SVES) for the parameter set specified in\n * the private key blob.\n *\n * The maximum size of the output plaintext may be queried by invoking\n * this function with pt = NULL.  In this case, no decryption is performed,\n * NTRU_OK is returned, and the maximum size the plaintext could be is\n * returned in pt_len.\n * Note that until the decryption is performed successfully, the actual size\n * of the resulting plaintext cannot be known.\n *\n * When pt != NULL, at invocation *pt_len must be the size of the pt buffer.\n * Upon return it is the actual size of the plaintext.\n *\n * Returns NTRU_OK if successful.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_PARAMETER if an argument pointer\n *  (other than pt) is NULL.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_LENGTH if a length argument\n *  (privkey_blob) is zero, or if ct_len is invalid for the parameter set.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_PRIVATE_KEY if the private-key blob is\n *  invalid (unknown format, corrupt, bad length).\n * Returns NTRU_ERROR_BASE + NTRU_BUFFER_TOO_SMALL if the plaintext buffer\n *  is too small.\n * Returns NTRU_ERROR_BASE + NTRU_NO_MEMORY if memory needed cannot be\n *  allocated from the heap.\n * Returns NTRU_ERROR_BASE + NTRU_FAIL if a decryption error occurs.\n */\n\nuint32_t\nntru_crypto_ntru_decrypt(\n    uint16_t       privkey_blob_len, /*     in - no. of octets in private key\n                                                 blob */\n    uint8_t const *privkey_blob,     /*     in - pointer to private key */\n    uint16_t       ct_len,           /*     in - no. of octets in ciphertext */\n    uint8_t const *ct,               /*     in - pointer to ciphertext */\n    uint16_t      *pt_len,           /* in/out - no. of octets in pt, addr for\n                                                 no. of octets in plaintext */\n    uint8_t       *pt)               /*    out - address for plaintext */\n{\n    NTRU_ENCRYPT_PARAM_SET *params = NULL;\n    uint8_t const          *privkey_packed = NULL;\n    uint8_t const          *pubkey_packed = NULL;\n    uint8_t                 privkey_pack_type = 0x00;\n    uint8_t                 pubkey_pack_type = 0x00;\n    size_t                  scratch_buf_len;\n    uint32_t                dF_r;\n    uint32_t                dF_r1 = 0;\n    uint32_t                dF_r2 = 0;\n    uint32_t                dF_r3 = 0;\n    uint16_t                num_scratch_polys;\n    uint16_t                pad_deg;\n    uint16_t                ring_mult_tmp_len;\n    uint16_t               *scratch_buf = NULL;\n    uint16_t               *ringel_buf1 = NULL;\n    uint16_t               *ringel_buf2 = NULL;\n    uint16_t               *i_buf = NULL;\n    uint8_t                *m_buf = NULL;\n    uint8_t                *tmp_buf = NULL;\n    uint8_t                *Mtrin_buf = NULL;\n    uint8_t                *M_buf = NULL;\n    uint8_t                *ptr = NULL;\n    NTRU_CRYPTO_HASH_ALGID  hash_algid;\n    uint8_t                 md_len;\n    uint16_t                mod_q_mask;\n    uint16_t                q_mod_p;\n    uint16_t                cm_len = 0;\n    uint16_t                num_zeros;\n    uint16_t                i;\n    bool                    decryption_ok = TRUE;\n    uint32_t                result = NTRU_OK;\n\n    /* check for bad parameters */\n\n    if (!privkey_blob || !pt_len)\n    {\n        NTRU_RET(NTRU_BAD_PARAMETER);\n    }\n\n    if (privkey_blob_len == 0)\n    {\n        NTRU_RET(NTRU_BAD_LENGTH);\n    }\n\n    /* get a pointer to the parameter-set parameters, the packing types for\n     * the public and private keys, and pointers to the packed public and\n     * private keys\n     */\n\n    if (!ntru_crypto_ntru_encrypt_key_parse(FALSE /* privkey */,\n                                            privkey_blob_len,\n                                            privkey_blob, &pubkey_pack_type,\n                                            &privkey_pack_type, &params,\n                                            &pubkey_packed, &privkey_packed))\n    {\n        NTRU_RET(NTRU_BAD_PRIVATE_KEY);\n    }\n\n    if(params->q_bits <= 8\n            || params->q_bits >= 16\n            || params->N_bits <= 8\n            || params->N_bits >= 16\n            || pubkey_pack_type != NTRU_ENCRYPT_KEY_PACKED_COEFFICIENTS\n            || (privkey_pack_type != NTRU_ENCRYPT_KEY_PACKED_TRITS\n                && privkey_pack_type != NTRU_ENCRYPT_KEY_PACKED_INDICES))\n    {\n        NTRU_RET(NTRU_UNSUPPORTED_PARAM_SET);\n    }\n\n    /* return the max plaintext size if requested */\n\n    if (!pt)\n    {\n        *pt_len = params->m_len_max;\n        NTRU_RET(NTRU_OK);\n    }\n\n    /* check that a ciphertext was provided */\n\n    if (!ct)\n    {\n        NTRU_RET(NTRU_BAD_PARAMETER);\n    }\n\n    /* cannot check the plaintext buffer size until after the plaintext\n     * is derived, if we allow plaintext buffers only as large as the\n     * actual plaintext\n     */\n\n    /* check the ciphertext length */\n\n    if (ct_len != (params->N * params->q_bits + 7) >> 3)\n    {\n        NTRU_RET(NTRU_BAD_LENGTH);\n    }\n\n    /* allocate memory for all operations */\n\n    ntru_ring_mult_indices_memreq(params->N, &num_scratch_polys, &pad_deg);\n\n    if (params->is_product_form)\n    {\n        dF_r1 =  params->dF_r & 0xff;\n        dF_r2 = (params->dF_r >>  8) & 0xff;\n        dF_r3 = (params->dF_r >> 16) & 0xff;\n        dF_r = dF_r1 + dF_r2 + dF_r3;\n        num_scratch_polys += 1; /* mult_product_indices needs space for a\n                                   mult_indices and one intermediate result */\n    }\n    else\n    {\n        dF_r = params->dF_r;\n    }\n    ring_mult_tmp_len = num_scratch_polys * pad_deg;\n\n    scratch_buf_len = (ring_mult_tmp_len << 1) +\n                                            /* X-byte temp buf for ring mult and\n                                                other intermediate results */\n                      (pad_deg << 2) +      /* 2 2N-byte bufs for ring elements\n                                                and overflow from temp buffer */\n                      (dF_r << 2) +         /* buffer for F, r indices */\n                      params->m_len_max;    /* buffer for plaintext */\n\n    scratch_buf = MALLOC(scratch_buf_len);\n    if (!scratch_buf)\n    {\n        NTRU_RET(NTRU_OUT_OF_MEMORY);\n    }\n\n    ringel_buf1 = scratch_buf + ring_mult_tmp_len;\n    ringel_buf2 = ringel_buf1 + pad_deg;\n    i_buf = ringel_buf2 + pad_deg;\n    m_buf = (uint8_t *)(i_buf + (dF_r << 1));\n    tmp_buf = (uint8_t *)scratch_buf;\n    Mtrin_buf = (uint8_t *)ringel_buf1;\n    M_buf = Mtrin_buf + params->N;\n\n    /* set hash algorithm and seed length based on security strength */\n\n    if (params->hash_algid == NTRU_CRYPTO_HASH_ALGID_SHA1)\n    {\n        hash_algid = NTRU_CRYPTO_HASH_ALGID_SHA1;\n        md_len = SHA_1_MD_LEN;\n    }\n    else if (params->hash_algid == NTRU_CRYPTO_HASH_ALGID_SHA256)\n    {\n        hash_algid = NTRU_CRYPTO_HASH_ALGID_SHA256;\n        md_len = SHA_256_MD_LEN;\n    }\n    else\n    {\n        FREE(scratch_buf);\n        NTRU_RET(NTRU_UNSUPPORTED_PARAM_SET);\n    }\n\n    /* set constants */\n\n    mod_q_mask = params->q - 1;\n    q_mod_p = params->q % 3;\n\n    /* unpack the ciphertext */\n\n    ntru_octets_2_elements(ct_len, ct, params->q_bits, ringel_buf2);\n\n    /* unpack the private key */\n\n    if (privkey_pack_type == NTRU_ENCRYPT_KEY_PACKED_TRITS)\n    {\n        ntru_packed_trits_2_indices(privkey_packed, params->N, i_buf,\n                                    i_buf + dF_r);\n\n    }\n    else if (privkey_pack_type == NTRU_ENCRYPT_KEY_PACKED_INDICES)\n    {\n        ntru_octets_2_elements(\n                (((uint16_t)dF_r << 1) * params->N_bits + 7) >> 3,\n                privkey_packed, params->N_bits, i_buf);\n    }\n    else\n    {\n        /* Unreachable due to supported parameter set check above */\n    }\n\n    /* form cm':\n     *  F * e\n     *  A = e * (1 + pF) mod q = e + pFe mod q\n     *  a = A in the range [-q/2, q/2)\n     *  cm' = a mod p\n     *\n     * first compute F*e w/o reduction mod q and store in ringel_buf1\n     */\n    if (params->is_product_form)\n    {\n        ntru_ring_mult_product_indices(ringel_buf2, (uint16_t)dF_r1,\n                                       (uint16_t)dF_r2, (uint16_t)dF_r3,\n                                       i_buf, params->N, params->q,\n                                       scratch_buf, ringel_buf1);\n    }\n    else\n    {\n        ntru_ring_mult_indices(ringel_buf2, (uint16_t)dF_r, (uint16_t)dF_r,\n                               i_buf, params->N, params->q,\n                               scratch_buf, ringel_buf1);\n    }\n\n    /* then let ringel_buf1 = e + 3*ringel_buf1 (mod q) = e + pFe mod q\n     * lift ringel_buf1 elements to integers in the range [-q/2, q/2)\n     * let Mtrin_buf = ringel_buf1 (mod 3) = cm'\n     */\n    for (i = 0; i < params->N; i++)\n    {\n        ringel_buf1[i] = (ringel_buf2[i] + 3 * ringel_buf1[i]) & mod_q_mask;\n\n        if (ringel_buf1[i] >= (params->q >> 1))\n        {\n            ringel_buf1[i] = ringel_buf1[i] - q_mod_p;\n        }\n\n        Mtrin_buf[i] = (uint8_t)(ringel_buf1[i] % 3);\n    }\n\n    /* check that the candidate message representative meets minimum weight\n     * requirements\n     */\n    if (!ntru_poly_check_min_weight(params->N,\n                                    Mtrin_buf, params->min_msg_rep_wt))\n    {\n        decryption_ok = FALSE;\n    }\n\n\n    /* form cR = e - cm' mod q */\n\n    for (i = 0; i < params->N; i++)\n    {\n        if (Mtrin_buf[i] == 1)\n        {\n            ringel_buf2[i] = (ringel_buf2[i]-1) & mod_q_mask;\n        }\n        else if (Mtrin_buf[i] == 2)\n        {\n            ringel_buf2[i] = (ringel_buf2[i]+1) & mod_q_mask;\n        }\n        else\n        {\n            ;\n        }\n    }\n\n    /* form cR mod 4 */\n\n    ntru_coeffs_mod4_2_octets(params->N, ringel_buf2, tmp_buf);\n\n    /* form mask */\n\n    result = ntru_mgftp1(hash_algid, md_len,\n                         params->min_MGF_hash_calls,\n                         (params->N + 3) / 4, tmp_buf,\n                         tmp_buf + params->N, params->N, tmp_buf);\n\n    if (result == NTRU_OK)\n    {\n        /* form cMtrin by subtracting mask from cm', mod p */\n\n        for (i = 0; i < params->N; i++)\n        {\n            Mtrin_buf[i] = Mtrin_buf[i] - tmp_buf[i];\n\n            if (Mtrin_buf[i] >= 3)\n            {\n                Mtrin_buf[i] += 3;\n            }\n        }\n\n        /* convert cMtrin to cM (Mtrin to Mbin) */\n\n        if (!ntru_trits_2_bits(Mtrin_buf, params->N, M_buf))\n        {\n            decryption_ok = FALSE;\n        }\n\n        /* validate the padded message cM and copy cm to m_buf */\n\n        ptr = M_buf + params->b_len;\n\n        if (params->m_len_len == 2)\n        {\n            cm_len = (uint16_t)(*ptr++) << 8;\n        }\n\n        cm_len |= (uint16_t)(*ptr++);\n\n        if (cm_len > params->m_len_max)\n        {\n            cm_len = params->m_len_max;\n            decryption_ok = FALSE;\n        }\n\n        memcpy(m_buf, ptr, cm_len);\n        ptr += cm_len;\n        num_zeros = params->m_len_max - cm_len + 1;\n\n        for (i = 0; i < num_zeros; i++)\n        {\n            if (ptr[i] != 0)\n            {\n                decryption_ok = FALSE;\n            }\n        }\n\n        /* form sData (OID || m || b || hTrunc) */\n\n        ptr = tmp_buf;\n        memcpy(ptr, params->OID, 3);\n        ptr += 3;\n        memcpy(ptr, m_buf, cm_len);\n        ptr += cm_len;\n        memcpy(ptr, M_buf, params->b_len);\n        ptr += params->b_len;\n        memcpy(ptr, pubkey_packed, params->sec_strength_len);\n        ptr += params->sec_strength_len;\n\n        /* generate cr */\n\n        result = ntru_gen_poly(hash_algid, md_len,\n                               params->min_IGF_hash_calls,\n                               (uint16_t)(ptr - tmp_buf),\n                               tmp_buf, tmp_buf,\n                               params->N, params->c_bits,\n                               params->no_bias_limit,\n                               params->is_product_form,\n                               params->dF_r << 1, i_buf);\n    }\n\n    if (result == NTRU_OK)\n    {\n        /* unpack the public key */\n\n        {\n            uint16_t pubkey_packed_len;\n            pubkey_packed_len = (params->N * params->q_bits + 7) >> 3;\n            ntru_octets_2_elements(pubkey_packed_len, pubkey_packed,\n                                   params->q_bits, ringel_buf1);\n        }\n\n        /* form cR' = h * cr */\n\n        if (params->is_product_form)\n        {\n            ntru_ring_mult_product_indices(ringel_buf1, (uint16_t)dF_r1,\n                                           (uint16_t)dF_r2, (uint16_t)dF_r3,\n                                           i_buf, params->N, params->q,\n                                           scratch_buf, ringel_buf1);\n        }\n        else\n        {\n            ntru_ring_mult_indices(ringel_buf1, (uint16_t)dF_r, (uint16_t)dF_r,\n                                   i_buf, params->N, params->q,\n                                   scratch_buf, ringel_buf1);\n        }\n\n        /* compare cR' to cR */\n\n        for (i = 0; i < params->N; i++)\n        {\n            if (ringel_buf1[i] != ringel_buf2[i])\n            {\n                decryption_ok = FALSE;\n            }\n        }\n\n        /* output plaintext and plaintext length */\n\n        if (decryption_ok)\n        {\n            if (*pt_len < cm_len)\n            {\n                memset(scratch_buf, 0, scratch_buf_len);\n                FREE(scratch_buf);\n                NTRU_RET(NTRU_BUFFER_TOO_SMALL);\n            }\n\n            memcpy(pt, m_buf, cm_len);\n            *pt_len = cm_len;\n        }\n    }\n\n    /* cleanup */\n\n    memset(scratch_buf, 0, scratch_buf_len);\n    FREE(scratch_buf);\n    \n    if (!decryption_ok)\n    {\n        NTRU_RET(NTRU_FAIL);\n    }\n    \n    return result;\n}\n\n\n/* ntru_crypto_ntru_encrypt_keygen\n *\n * Implements key generation for NTRUEncrypt for the parameter set specified.\n *\n * Before invoking this function, a DRBG must be instantiated using\n * ntru_crypto_drbg_instantiate() to obtain a DRBG handle, and in that\n * instantiation the requested security strength must be at least as large\n * as the security strength of the NTRU parameter set being used.\n * Failure to instantiate the DRBG with the proper security strength will\n * result in this function returning DRBG_ERROR_BASE + DRBG_BAD_LENGTH.\n *\n * The required minimum size of the output public-key buffer (pubkey_blob)\n * may be queried by invoking this function with pubkey_blob = NULL.\n * In this case, no key generation is performed, NTRU_OK is returned, and\n * the required minimum size for pubkey_blob is returned in pubkey_blob_len.\n *\n * The required minimum size of the output private-key buffer (privkey_blob)\n * may be queried by invoking this function with privkey_blob = NULL.\n * In this case, no key generation is performed, NTRU_OK is returned, and\n * the required minimum size for privkey_blob is returned in privkey_blob_len.\n *\n * The required minimum sizes of both pubkey_blob and privkey_blob may be\n * queried as described above, in a single invocation of this function.\n *\n * When pubkey_blob != NULL and privkey_blob != NULL, at invocation\n * *pubkey_blob_len must be the size of the pubkey_blob buffer and\n * *privkey_blob_len must be the size of the privkey_blob buffer.\n * Upon return, *pubkey_blob_len is the actual size of the public-key blob\n * and *privkey_blob_len is the actual size of the private-key blob.\n *\n * Returns NTRU_OK if successful.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_PARAMETER if an argument pointer\n *  (other than pubkey_blob or privkey_blob) is NULL.\n * Returns NTRU_ERROR_BASE + NTRU_INVALID_PARAMETER_SET if the parameter-set\n *  ID is invalid.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_LENGTH if a length argument is invalid.\n * Returns NTRU_ERROR_BASE + NTRU_BUFFER_TOO_SMALL if either the pubkey_blob\n * buffer or the privkey_blob buffer is too small.\n * Returns NTRU_ERROR_BASE + NTRU_NO_MEMORY if memory needed cannot be\n *  allocated from the heap.\n * Returns NTRU_ERROR_BASE + NTRU_FAIL if the polynomial generated for f is\n *  not invertible in (Z/qZ)[X]/(X^N - 1), which is extremely unlikely.\n *  Should this occur, this function should simply be invoked again.\n */\n\nuint32_t\nntru_crypto_ntru_encrypt_keygen(\n    DRBG_HANDLE                drbg_handle,      /*     in - handle of DRBG */\n    NTRU_ENCRYPT_PARAM_SET_ID  param_set_id,     /*     in - parameter set ID */\n    uint16_t                  *pubkey_blob_len,  /* in/out - no. of octets in\n                                                             pubkey_blob, addr\n                                                             for no. of octets\n                                                             in pubkey_blob */\n    uint8_t                   *pubkey_blob,      /*    out - address for\n                                                             public key blob */\n    uint16_t                  *privkey_blob_len, /* in/out - no. of octets in\n                                                             privkey_blob, addr\n                                                             for no. of octets\n                                                             in privkey_blob */\n    uint8_t                   *privkey_blob)     /*    out - address for\n                                                             private key blob */\n{\n    NTRU_ENCRYPT_PARAM_SET *params = NULL;\n    uint16_t                public_key_blob_len;\n    uint16_t                private_key_blob_len;\n    uint8_t                 pubkey_pack_type;\n    uint8_t                 privkey_pack_type;\n    size_t                  scratch_buf_len;\n    uint32_t                dF;\n    uint32_t                dF1 = 0;\n    uint32_t                dF2 = 0;\n    uint32_t                dF3 = 0;\n    uint16_t                pad_deg;\n    uint16_t                total_polys;\n    uint16_t                num_scratch_polys;\n    uint16_t               *scratch_buf = NULL;\n    uint16_t               *ringel_buf1 = NULL;\n    uint16_t               *ringel_buf2 = NULL;\n    uint16_t               *F_buf = NULL;\n    uint8_t                *tmp_buf = NULL;\n    uint16_t                mod_q_mask;\n    NTRU_CRYPTO_HASH_ALGID  hash_algid;\n    uint8_t                 md_len;\n    uint16_t                seed_len;\n    uint32_t                result = NTRU_OK;\n\n    /* get a pointer to the parameter-set parameters */\n\n    if ((params = ntru_encrypt_get_params_with_id(param_set_id)) == NULL)\n    {\n        NTRU_RET(NTRU_INVALID_PARAMETER_SET);\n    }\n\n    /* check for bad parameters */\n\n    if (!pubkey_blob_len || !privkey_blob_len)\n    {\n        NTRU_RET(NTRU_BAD_PARAMETER);\n    }\n\n    /* get public and private key packing types and blob lengths */\n\n    ntru_crypto_ntru_encrypt_key_get_blob_params(params, &pubkey_pack_type,\n                                                 &public_key_blob_len,\n                                                 &privkey_pack_type,\n                                                 &private_key_blob_len);\n\n    /* return the pubkey_blob size and/or privkey_blob size if requested */\n\n    if (!pubkey_blob || !privkey_blob)\n    {\n        if (!pubkey_blob)\n        {\n            *pubkey_blob_len = public_key_blob_len;\n        }\n\n        if (!privkey_blob)\n        {\n            *privkey_blob_len = private_key_blob_len;\n        }\n\n        NTRU_RET(NTRU_OK);\n    }\n\n    /* check size of output buffers */\n\n    if ((*pubkey_blob_len < public_key_blob_len) ||\n            (*privkey_blob_len < private_key_blob_len))\n    {\n        NTRU_RET(NTRU_BUFFER_TOO_SMALL);\n    }\n\n    /* Allocate memory for all operations. We need:\n     *  - 2 polynomials for results: ringel_buf1 and ringel_buf2.\n     *  - scratch space for ntru_ring_mult_coefficients (which is\n     *    implementation dependent) plus one additional polynomial\n     *    of the same size for ntru_ring_lift_inv_pow2_x.\n     *  - 2*dF coefficients for F\n     */\n    ntru_ring_mult_coefficients_memreq(params->N, &num_scratch_polys, &pad_deg);\n    num_scratch_polys += 1; /* ntru_ring_lift_... */\n\n    total_polys = num_scratch_polys;\n    if (params->is_product_form)\n    {\n        dF1 =  params->dF_r & 0xff;\n        dF2 = (params->dF_r >> 8) & 0xff;\n        dF3 = (params->dF_r >> 16) & 0xff;\n        dF = dF1 + dF2 + dF3;\n        /* For product form keys we can overlap ringel_buf1\n         * and the scratch space since mult. by f uses F_buf.\n         * so only add room for ringel_buf2 */\n        num_scratch_polys -= 1;\n        total_polys += 1;\n    }\n    else\n    {\n        dF = params->dF_r;\n        total_polys += 2; /* ringel_buf{1,2} */\n    }\n\n    scratch_buf_len = total_polys * pad_deg * sizeof(uint16_t);\n    scratch_buf_len += 2 * dF * sizeof(uint16_t);\n    scratch_buf = MALLOC(scratch_buf_len);\n    if (!scratch_buf)\n    {\n        NTRU_RET(NTRU_OUT_OF_MEMORY);\n    }\n    memset(scratch_buf, 0, scratch_buf_len);\n\n    ringel_buf1 = scratch_buf + num_scratch_polys*pad_deg;\n    ringel_buf2 = ringel_buf1 + pad_deg;\n    F_buf       = ringel_buf2 + pad_deg;\n    tmp_buf     = (uint8_t *)scratch_buf;\n\n    /* set hash algorithm and seed length based on security strength */\n\n    if (params->hash_algid == NTRU_CRYPTO_HASH_ALGID_SHA1)\n    {\n        hash_algid = NTRU_CRYPTO_HASH_ALGID_SHA1;\n        md_len = SHA_1_MD_LEN;\n    }\n    else if (params->hash_algid == NTRU_CRYPTO_HASH_ALGID_SHA256)\n    {\n        hash_algid = NTRU_CRYPTO_HASH_ALGID_SHA256;\n        md_len = SHA_256_MD_LEN;\n    }\n    else\n    {\n        FREE(scratch_buf);\n        NTRU_RET(NTRU_UNSUPPORTED_PARAM_SET);\n    }\n\n    seed_len = 2 * params->sec_strength_len;\n\n    /* set constants */\n\n    mod_q_mask = params->q - 1;\n\n    /* get random bytes for seed for generating trinary F\n     * as a list of indices\n     */\n\n    result = ntru_crypto_drbg_generate(drbg_handle,\n                                       params->sec_strength_len << 3,\n                                       seed_len, tmp_buf);\n\n    if (result == NTRU_OK)\n    {\n\n        /* generate F */\n\n        result = ntru_gen_poly(hash_algid, md_len,\n                               params->min_IGF_hash_calls,\n                               seed_len, tmp_buf, tmp_buf,\n                               params->N, params->c_bits,\n                               params->no_bias_limit,\n                               params->is_product_form,\n                               params->dF_r << 1, F_buf);\n    }\n\n    if (result == NTRU_OK)\n    {\n        uint32_t i;\n\n        memset(ringel_buf1, 0, params->N * sizeof(uint16_t));\n\n        /* form F as a ring element */\n\n        if (params->is_product_form)\n        {\n            uint32_t dF3_offset = (dF1 + dF2) << 1;\n\n            /* form F1 as a ring element */\n\n            for (i = 0; i < dF1; i++)\n            {\n                ringel_buf1[F_buf[i]] = 1;\n            }\n\n            for (; i < (dF1 << 1); i++)\n            {\n                ringel_buf1[F_buf[i]] = mod_q_mask;\n            }\n\n            /* form F1 * F2 */\n\n            ntru_ring_mult_indices(ringel_buf1, (uint16_t)dF2, (uint16_t)dF2,\n                                   F_buf + (dF1 << 1), params->N, params->q,\n                                   scratch_buf, ringel_buf1);\n\n            /* form (F1 * F2) + F3 */\n\n            for (i = 0; i < dF3; i++)\n            {\n                uint16_t index = F_buf[dF3_offset + i];\n                ringel_buf1[index] = (ringel_buf1[index]+1) & mod_q_mask;\n            }\n\n            for (; i < (dF3 << 1); i++)\n            {\n                uint16_t index = F_buf[dF3_offset + i];\n                ringel_buf1[index] = (ringel_buf1[index]-1) & mod_q_mask;\n            }\n\n        }\n        else\n        {\n            /* form F as a ring element */\n\n            for (i = 0; i < dF; i++)\n            {\n                ringel_buf1[F_buf[i]] = 1;\n            }\n\n            for (; i < (dF << 1); i++)\n            {\n                ringel_buf1[F_buf[i]] = mod_q_mask;\n            }\n        }\n\n        /* form f = 1 + pF */\n\n        for (i = 0; i < params->N; i++)\n        {\n            ringel_buf1[i] = (ringel_buf1[i] * 3) & mod_q_mask;\n        }\n\n        ringel_buf1[0] = (ringel_buf1[0] + 1) & mod_q_mask;\n\n        /* find f^-1 in (Z/2Z)[X]/(X^N - 1) */\n\n        if (!ntru_ring_inv(ringel_buf1, params->N, scratch_buf, ringel_buf2))\n        {\n            result = NTRU_RESULT(NTRU_FAIL);\n        }\n    }\n\n    if (result == NTRU_OK)\n    {\n        /* lift f^-1 in (Z/2Z)[X]/(X^N - 1) to f^-1 in (Z/qZ)[X]/(X^N -1) */\n        if(params->is_product_form)\n        {\n            result = ntru_ring_lift_inv_pow2_product(ringel_buf2,\n                    (uint16_t)dF1, (uint16_t)dF2, (uint16_t)dF3,\n                    F_buf, params->N, params->q, scratch_buf);\n        }\n        else\n        {\n            result = ntru_ring_lift_inv_pow2_standard(ringel_buf2,\n                    ringel_buf1, params->N, params->q, scratch_buf);\n        }\n    }\n\n    if (result == NTRU_OK)\n    {\n\n        /* get random bytes for seed for generating trinary g\n         * as a list of indices\n         */\n        result = ntru_crypto_drbg_generate(drbg_handle,\n                                           params->sec_strength_len << 3,\n                                           seed_len, tmp_buf);\n    }\n\n    if (result == NTRU_OK)\n    {\n        uint16_t min_IGF_hash_calls =\n            ((((params->dg << 2) + 2) * params->N_bits) + (md_len << 3) - 1) /\n            (md_len << 3);\n\n        /* generate g */\n\n        result = ntru_gen_poly(hash_algid, md_len,\n                               (uint8_t)min_IGF_hash_calls,\n                               seed_len, tmp_buf, tmp_buf,\n                               params->N, params->c_bits,\n                               params->no_bias_limit, FALSE,\n                               (params->dg << 1) + 1, ringel_buf1);\n    }\n\n    if (result == NTRU_OK)\n    {\n        uint16_t i;\n\n        /* compute h = p * (f^-1 * g) mod q */\n\n        ntru_ring_mult_indices(ringel_buf2, params->dg + 1, params->dg,\n                               ringel_buf1, params->N, params->q, scratch_buf,\n                               ringel_buf2);\n\n        for (i = 0; i < params->N; i++)\n        {\n            ringel_buf2[i] = (ringel_buf2[i] * 3) & mod_q_mask;\n        }\n\n        /* create public key blob */\n\n        result = ntru_crypto_ntru_encrypt_key_create_pubkey_blob(params,\n                ringel_buf2, pubkey_pack_type, pubkey_blob);\n        *pubkey_blob_len = public_key_blob_len;\n    }\n\n    if (result == NTRU_OK)\n    {\n        /* create private key blob */\n        result = ntru_crypto_ntru_encrypt_key_create_privkey_blob(params,\n                ringel_buf2, F_buf, privkey_pack_type, tmp_buf, privkey_blob);\n        *privkey_blob_len = private_key_blob_len;\n    }\n\n    /* cleanup */\n\n    memset(scratch_buf, 0, scratch_buf_len);\n    FREE(scratch_buf);\n\n    return result;\n}\n\n\n/* DER-encoding prefix template for NTRU public keys,\n * with parameter-set-specific fields nomalized\n */\n\nstatic uint8_t const der_prefix_template[] = {\n    0x30, 0x82,\n    0x00, 0x25,                                 /* add pubkey length 2 */\n    0x30, 0x1a, 0x06, 0x0b, 0x2b, 0x06, 0x01,\n    0x04, 0x01, 0xc1, 0x16, 0x01, 0x01, 0x01, \n    0x01,                                       /* end of NTRU OID compare */\n    0x06, 0x0b, 0x2b, 0x06, 0x01, 0x04, 0x01,\n    0xc1, 0x16, 0x01, 0x01, 0x02,\n    0x00,                                       /* set param-set DER id 31 */\n    0x03, 0x82,\n    0x00, 0x05,                                 /* add pubkey length 34 */\n    0x00, 0x04, 0x82,\n    0x00, 0x00,                                 /* add pubkey length 39 */\n};\n\n\n/* add_16_to_8s\n *\n * adds a 16-bit value to two bytes\n */\n\nstatic void\nadd_16_to_8s(\n    uint16_t  a,\n    uint8_t  *b)\n{\n    uint16_t tmp = ((uint16_t)b[0] << 8) + b[1];\n\n    tmp = tmp + a;\n    b[0] = (uint8_t)((tmp >> 8) & 0xff);\n    b[1] = (uint8_t)(tmp & 0xff);\n    \n    return;\n}\n\n\n/* sub_16_from_8s\n *\n * subtracts a 16-bit value from two bytes\n */\n\nstatic void\nsub_16_from_8s(\n    uint16_t  a,\n    uint8_t  *b)\n{\n    uint16_t tmp = ((uint16_t)b[0] << 8) + b[1];\n\n    tmp = tmp - a;\n    b[0] = (uint8_t)((tmp >> 8) & 0xff);\n    b[1] = (uint8_t)(tmp & 0xff);\n    \n    return;\n}\n\n\n/* ntru_crypto_ntru_encrypt_publicKey2SubjectPublicKeyInfo\n *\n * DER-encodes an NTRUEncrypt public-key from a public-key blob into a\n * SubjectPublicKeyInfo field for inclusion in an X.509 certificate.\n *\n * The required minimum size of the output SubjectPublicKeyInfo buffer\n * (encoded_subjectPublicKeyInfo) may be queried by invoking this function\n * with encoded_subjectPublicKeyInfo = NULL.  In this case, no encoding is\n * performed, NTRU_OK is returned, and the required minimum size for\n * encoded_subjectPublicKeyInfo is returned in encoded_subjectPublicKeyInfo_len.\n *\n * When encoded_subjectPublicKeyInfo != NULL, at invocation\n * *encoded_subjectPublicKeyInfo_len must be the size of the\n * encoded_subjectPublicKeyInfo buffer.\n * Upon return, it is the actual size of the encoded public key.\n *\n * Returns NTRU_OK if successful.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_PARAMETER if an argument pointer\n *  (other than encoded_subjectPublicKeyInfo) is NULL.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_LENGTH if pubkey_blob_len is zero.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_PUBLIC_KEY if the public-key blob is\n *  invalid (unknown format, corrupt, bad length).\n * Returns NTRU_ERROR_BASE + NTRU_BUFFER_TOO_SMALL if the SubjectPublicKeyInfo\n *  buffer is too small.\n */\n\nuint32_t\nntru_crypto_ntru_encrypt_publicKey2SubjectPublicKeyInfo(\n    uint16_t       pubkey_blob_len, /*     in - no. of octets in public-key\n                                                blob */\n    uint8_t const *pubkey_blob,     /*     in - ptr to public-key blob */\n    uint16_t      *encoded_subjectPublicKeyInfo_len,\n                                    /* in/out - no. of octets in encoded info,\n                                                address for no. of octets in\n                                                encoded info */\n    uint8_t       *encoded_subjectPublicKeyInfo)\n                                    /*    out - address for encoded info */\n{\n    NTRU_ENCRYPT_PARAM_SET *params = NULL;\n    uint8_t const          *pubkey_packed = NULL;\n    uint8_t                 pubkey_pack_type;\n    uint16_t                packed_pubkey_len;\n    uint16_t                encoded_len;\n\n    /* check for bad parameters */\n\n    if (!pubkey_blob || !encoded_subjectPublicKeyInfo_len)\n    {\n        NTRU_RET(NTRU_BAD_PARAMETER);\n    }\n    \n    if (pubkey_blob_len == 0)\n    {\n        NTRU_RET(NTRU_BAD_LENGTH);\n    }\n\n    /* get a pointer to the parameter-set parameters, the packing type for\n     * the public key, and a pointer to the packed public key\n     */\n\n    if (!ntru_crypto_ntru_encrypt_key_parse(TRUE /* pubkey */, pubkey_blob_len,\n                                            pubkey_blob, &pubkey_pack_type,\n                                            NULL, &params, &pubkey_packed,\n                                            NULL))\n    {\n        NTRU_RET(NTRU_BAD_PUBLIC_KEY);\n    }\n    \n    /* return the encoded_subjectPublicKeyInfo size if requested */\n\n    packed_pubkey_len = (params->N * params->q_bits + 7) >> 3;\n    encoded_len = sizeof(der_prefix_template) + packed_pubkey_len;\n    \n    if (!encoded_subjectPublicKeyInfo)\n    {\n        *encoded_subjectPublicKeyInfo_len = encoded_len;\n        NTRU_RET(NTRU_OK);\n    }\n\n    /* check the encoded_subjectPublicKeyInfo buffer size */\n\n    if (*encoded_subjectPublicKeyInfo_len < encoded_len)\n    {\n        NTRU_RET(NTRU_BUFFER_TOO_SMALL);\n    }\n\n    /* form the encoded subjectPublicKey */\n\n    memcpy(encoded_subjectPublicKeyInfo, der_prefix_template,\n           sizeof(der_prefix_template));\n    \n    add_16_to_8s(packed_pubkey_len, encoded_subjectPublicKeyInfo + 2);\n    add_16_to_8s(packed_pubkey_len, encoded_subjectPublicKeyInfo + 34);\n    add_16_to_8s(packed_pubkey_len, encoded_subjectPublicKeyInfo + 39);\n    encoded_subjectPublicKeyInfo[31] = params->der_id;\n    \n    memcpy(encoded_subjectPublicKeyInfo + sizeof(der_prefix_template),\n           pubkey_packed, packed_pubkey_len);\n\n    *encoded_subjectPublicKeyInfo_len = encoded_len;\n\n    NTRU_RET(NTRU_OK);\n}\n\n\n/* ntru_crypto_ntru_encrypt_subjectPublicKeyInfo2PublicKey\n *\n * Decodes a DER-encoded NTRUEncrypt public-key from a\n * SubjectPublicKeyInfo field in an X.509 certificate and returns the\n * public-key blob itself.\n *\n * The required minimum size of the output public-key buffer (pubkey_blob)\n * may be queried by invoking this function with pubkey_blob = NULL.\n * In this case, no decoding is performed, NTRU_OK is returned, and the\n * required minimum size for pubkey_blob is returned in pubkey_blob_len.\n *\n * When pubkey_blob != NULL, at invocation *pubkey_blob_len must be the\n * size of the pubkey_blob buffer.\n * Upon return, it is the actual size of the public-key blob.\n *\n * Returns NTRU_OK if successful.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_LENGTH if the encoded data buffer\n *  does not contain a full der prefix and public key.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_PARAMETER if an argument pointer\n *  (other than pubkey_blob) is NULL.\n * Returns NTRU_ERROR_BASE + NTRU_BAD_ENCODING if the encoded data is\n *  an invalid encoding of an NTRU public key.\n * Returns NTRU_ERROR_BASE + NTRU_OID_NOT_RECOGNIZED if the\n *  encoded data contains an OID that identifies an object other than\n *  an NTRU public key.\n * Returns NTRU_ERROR_BASE + NTRU_BUFFER_TOO_SMALL if the pubkey_blob buffer\n *  is too small.\n */\n\nuint32_t\nntru_crypto_ntru_encrypt_subjectPublicKeyInfo2PublicKey(\n    uint8_t const  *encoded_data,    /*     in - ptr to subjectPublicKeyInfo\n                                                 in the encoded data */\n    uint16_t       *pubkey_blob_len, /* in/out - no. of octets in pubkey blob,\n                                                 address for no. of octets in\n                                                 pubkey blob */\n    uint8_t        *pubkey_blob,     /*    out - address for pubkey blob */\n    uint8_t       **next,            /*    out - address for ptr to encoded\n                                                 data following the \n                                                 subjectPublicKeyInfo */\n    uint32_t       *remaining_data_len) /* in/out - number of bytes remaining in\n                                                    buffer *next */\n{\n    NTRU_ENCRYPT_PARAM_SET *params = NULL;\n    uint8_t                 prefix_buf[41];\n    bool                    der_id_valid;\n    uint16_t                packed_pubkey_len = 0;\n    uint8_t                 pubkey_pack_type;\n    uint16_t                public_key_blob_len;\n    uint8_t                *data_ptr;\n    uint32_t                data_len;\n\n    /* check for bad parameters */\n\n    if (!encoded_data || !pubkey_blob_len || !next || !remaining_data_len)\n    {\n        NTRU_RET(NTRU_BAD_PARAMETER);\n    }\n\n    data_len = *remaining_data_len;\n    if (data_len < sizeof(prefix_buf))\n    {\n        NTRU_RET(NTRU_BAD_LENGTH);\n    }\n\n    /* determine if data to be decoded is a valid encoding of an NTRU\n     * public key\n     */\n\n    data_ptr = (uint8_t *)encoded_data;\n    memcpy(prefix_buf, data_ptr, sizeof(prefix_buf));\n\n    /* get a pointer to the parameter-set parameters */\n\n    if ((params = ntru_encrypt_get_params_with_DER_id(data_ptr[31])) == NULL)\n    {\n        der_id_valid = FALSE;\n\n        /* normalize the prefix-buffer data used in an NTRU OID comparison */\n\n        prefix_buf[2] = der_prefix_template[2];\n        prefix_buf[3] = der_prefix_template[3];\n\n    }\n    else\n    {\n        der_id_valid = TRUE;\n\n        /* normalize the prefix-buffer data for the specific parameter set */\n\n        packed_pubkey_len = (params->N * params->q_bits + 7) >> 3;\n        sub_16_from_8s(packed_pubkey_len, prefix_buf + 2);\n        sub_16_from_8s(packed_pubkey_len, prefix_buf + 34);\n        sub_16_from_8s(packed_pubkey_len, prefix_buf + 39);\n        prefix_buf[31] = 0;\n        /*prefix_buf[40] = 0; */\n    }\n\n    /* validate the DER prefix encoding */\n\n    if (!der_id_valid || memcmp(prefix_buf, der_prefix_template,\n               sizeof(der_prefix_template)))\n    {\n\n        /* bad DER prefix, so determine if this is a bad NTRU encoding or an\n         * unknown OID by comparing the first 18 octets\n         */\n\n        if (memcmp(prefix_buf, der_prefix_template, 18) == 0)\n        {\n            NTRU_RET(NTRU_OID_NOT_RECOGNIZED);\n        }\n        else\n        {\n            NTRU_RET(NTRU_BAD_ENCODING);\n        }\n    }\n\n    /* done with prefix */\n\n    data_ptr += sizeof(prefix_buf);\n    data_len -= sizeof(prefix_buf);\n\n    /* get public key packing type and blob length */\n\n    ntru_crypto_ntru_encrypt_key_get_blob_params(params, &pubkey_pack_type,\n                                                 &public_key_blob_len, NULL,\n                                                 NULL);\n\n    /* return the pubkey_blob size if requested */\n\n    if (!pubkey_blob)\n    {\n        *pubkey_blob_len = public_key_blob_len;\n        NTRU_RET(NTRU_OK);\n    }\n\n    /* check size of output buffer */\n\n    if (*pubkey_blob_len < public_key_blob_len)\n    {\n        NTRU_RET(NTRU_BUFFER_TOO_SMALL);\n    }\n\n    /* check that blob contains additional data of length packed_pubkey_len */\n    if(data_len < packed_pubkey_len)\n    {\n        NTRU_RET(NTRU_BAD_LENGTH);\n    }\n\n    /* check that the public key pack type is supported */\n    if(pubkey_pack_type != NTRU_ENCRYPT_KEY_PACKED_COEFFICIENTS)\n    {\n        NTRU_RET(NTRU_BAD_PUBLIC_KEY);\n    }\n\n    /* create the public-key blob */\n    ntru_crypto_ntru_encrypt_key_recreate_pubkey_blob(params, packed_pubkey_len,\n                                     data_ptr, pubkey_pack_type, pubkey_blob);\n    *pubkey_blob_len = public_key_blob_len;\n\n    data_ptr += packed_pubkey_len;\n    data_len -= packed_pubkey_len;\n\n    /* check whether the buffer is empty and update *next */\n    if(data_len > 0)\n    {\n        *next = data_ptr;\n        *remaining_data_len = data_len;\n    }\n    else\n    {\n        *next = NULL;\n        *remaining_data_len = 0;\n    }\n\n    NTRU_RET(NTRU_OK);\n}\n\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_ntru_encrypt_key.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File: ntru_crypto_ntru_encrypt_key.c\n *\n * Contents: Routines for exporting and importing public and private keys\n *           for NTRUEncrypt.\n *\n *****************************************************************************/\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_ntru_encrypt_key.h\"\n\n\n/* ntru_crypto_ntru_encrypt_key_parse\n *\n * Parses an NTRUEncrypt key blob.\n * If the blob is not corrupt, returns packing types for public and private\n * keys, a pointer to the parameter set, a pointer to the public key, and\n * a pointer to the private key if it exists.\n *\n * Returns TRUE if successful.\n * Returns FALSE if the blob is invalid.\n */\n\nbool\nntru_crypto_ntru_encrypt_key_parse(\n    bool                     pubkey_parse,      /*  in - if parsing pubkey\n                                                         blob */\n    uint16_t                 key_blob_len,      /*  in - no. octets in key\n                                                         blob */\n    uint8_t const           *key_blob,          /*  in - pointer to key blob */\n    uint8_t                 *pubkey_pack_type,  /* out - addr for pubkey\n                                                         packing type */\n    uint8_t                 *privkey_pack_type, /* out - addr for privkey\n                                                         packing type */\n    NTRU_ENCRYPT_PARAM_SET **params,            /* out - addr for ptr to\n                                                         parameter set */\n    uint8_t const          **pubkey,            /* out - addr for ptr to\n                                                         packed pubkey */\n    uint8_t const          **privkey)           /* out - addr for ptr to\n                                                         packed privkey */\n{\n    uint8_t tag;\n\n    /* parse key blob based on tag */\n\n    tag = key_blob[0];\n    switch (tag)\n    {\n        case NTRU_ENCRYPT_PUBKEY_TAG:\n\n            if (!pubkey_parse)\n            {\n                return FALSE;\n            }\n\n            break;\n\n        case NTRU_ENCRYPT_PRIVKEY_DEFAULT_TAG:\n        case NTRU_ENCRYPT_PRIVKEY_TRITS_TAG:\n        case NTRU_ENCRYPT_PRIVKEY_INDICES_TAG:\n\n            if (pubkey_parse)\n            {\n                return FALSE;\n            }\n            break;\n\n        default:\n            return FALSE;\n            break;\n    }\n\n    switch (tag)\n    {\n        case NTRU_ENCRYPT_PUBKEY_TAG:\n        case NTRU_ENCRYPT_PRIVKEY_DEFAULT_TAG:\n        case NTRU_ENCRYPT_PRIVKEY_TRITS_TAG:\n        case NTRU_ENCRYPT_PRIVKEY_INDICES_TAG:\n\n            /* Version 0:\n             *  byte  0:   tag\n             *  byte  1:   no. of octets in OID\n             *  bytes 2-4: OID\n             *  bytes 5- : packed pubkey\n             *             [packed privkey]\n             */\n\n        {\n            NTRU_ENCRYPT_PARAM_SET *p = NULL;\n            uint16_t pubkey_packed_len;\n\n            /* check OID length and minimum blob length for tag and OID */\n\n            if ((key_blob_len < 5) || (key_blob[1] != 3))\n            {\n                return FALSE;\n            }\n            \n            /* get a pointer to the parameter set corresponding to the OID */\n\n            if ((p = ntru_encrypt_get_params_with_OID(key_blob + 2)) == NULL)\n            {\n                return FALSE;\n            }\n            \n            /* check blob length and assign pointers to blob fields */\n\n            pubkey_packed_len = (p->N * p->q_bits + 7) / 8;\n            \n            if (pubkey_parse) /* public-key parsing */\n            {\n                if (key_blob_len != 5 + pubkey_packed_len)\n                {\n                    return FALSE;\n                }\n\n                *pubkey = key_blob + 5;\n\n            }\n            else /* private-key parsing */\n            {\n                uint16_t privkey_packed_len;\n                uint16_t privkey_packed_trits_len = (p->N + 4) / 5;\n                uint16_t privkey_packed_indices_len;\n                uint16_t dF;\n\n                /* check packing type for product-form private keys */\n\n                if (p->is_product_form &&\n                        (tag == NTRU_ENCRYPT_PRIVKEY_TRITS_TAG))\n                {\n                    return FALSE;\n                }\n\n                /* set packed-key length for packed indices */\n\n                if (p->is_product_form)\n                {\n                    dF = (uint16_t)( (p->dF_r & 0xff) +            /* df1 */\n                                    ((p->dF_r >>  8) & 0xff) +     /* df2 */\n                                    ((p->dF_r >> 16) & 0xff));     /* df3 */\n                }\n                else\n                {\n                    dF = (uint16_t)p->dF_r;\n                }\n                \n                privkey_packed_indices_len = ((dF << 1) * p->N_bits + 7) >> 3;\n\n                /* set private-key packing type if defaulted */\n\n                if (tag == NTRU_ENCRYPT_PRIVKEY_DEFAULT_TAG)\n                {\n                    if (p->is_product_form ||\n                            (privkey_packed_indices_len <=\n                             privkey_packed_trits_len))\n                    {\n                        tag = NTRU_ENCRYPT_PRIVKEY_INDICES_TAG;\n                    }\n                    else\n                    {\n                        tag = NTRU_ENCRYPT_PRIVKEY_TRITS_TAG;\n                    }\n                }\n\n                if (tag == NTRU_ENCRYPT_PRIVKEY_TRITS_TAG)\n                {\n                    privkey_packed_len = privkey_packed_trits_len;\n                }\n                else\n                {\n                    privkey_packed_len = privkey_packed_indices_len;\n                }\n\n                if (key_blob_len != 5 + pubkey_packed_len + privkey_packed_len)\n                {\n                    return FALSE;\n                }\n\n                *pubkey = key_blob + 5;\n                *privkey = *pubkey + pubkey_packed_len;\n                *privkey_pack_type = (tag == NTRU_ENCRYPT_PRIVKEY_TRITS_TAG) ?\n                    NTRU_ENCRYPT_KEY_PACKED_TRITS :\n                    NTRU_ENCRYPT_KEY_PACKED_INDICES;\n            }\n\n            /* return parameter set pointer */\n\n            *pubkey_pack_type = NTRU_ENCRYPT_KEY_PACKED_COEFFICIENTS;\n            *params = p;\n        }\n            \n        default:\n            break;  /* can't get here */\n    }\n    \n    return TRUE;\n}\n\n\n/* ntru_crypto_ntru_encrypt_key_get_blob_params\n *\n * Returns public and private key packing types and blob lengths given\n * a packing format.  For now, only a default packing format exists.\n *\n * Only public-key params may be returned by setting privkey_pack_type\n * and privkey_blob_len to NULL.\n */\n\nvoid\nntru_crypto_ntru_encrypt_key_get_blob_params(\n    NTRU_ENCRYPT_PARAM_SET const *params,             /*  in - pointer to\n                                                               param set\n                                                               parameters */\n    uint8_t                      *pubkey_pack_type,   /* out - addr for pubkey\n                                                               packing type */\n    uint16_t                     *pubkey_blob_len,    /* out - addr for no. of\n                                                               bytes in\n                                                               pubkey blob */\n    uint8_t                      *privkey_pack_type,  /* out - addr for privkey\n                                                               packing type */\n    uint16_t                     *privkey_blob_len)   /* out - addr for no. of\n                                                               bytes in\n                                                               privkey blob */\n{\n    uint16_t pubkey_packed_len = (params->N * params->q_bits + 7) >> 3;\n\n    *pubkey_pack_type = NTRU_ENCRYPT_KEY_PACKED_COEFFICIENTS;\n    *pubkey_blob_len = 5 + pubkey_packed_len;\n\n    if (privkey_pack_type && privkey_blob_len)\n    {\n        uint16_t privkey_packed_trits_len = (params->N + 4) / 5;\n        uint16_t privkey_packed_indices_len;\n        uint16_t dF;\n\n        if (params->is_product_form)\n        {\n            dF = (uint16_t)( (params->dF_r & 0xff) +            /* df1 */\n                            ((params->dF_r >>  8) & 0xff) +     /* df2 */\n                            ((params->dF_r >> 16) & 0xff));     /* df3 */\n        }\n        else\n        {\n            dF = (uint16_t)params->dF_r;\n        }\n        \n        privkey_packed_indices_len = ((dF << 1) * params->N_bits + 7) >> 3;\n\n        if (params->is_product_form ||\n                (privkey_packed_indices_len <= privkey_packed_trits_len))\n        {\n            *privkey_pack_type = NTRU_ENCRYPT_KEY_PACKED_INDICES;\n            *privkey_blob_len =\n                5 + pubkey_packed_len + privkey_packed_indices_len;\n        }\n        else\n        {\n            *privkey_pack_type = NTRU_ENCRYPT_KEY_PACKED_TRITS;\n            *privkey_blob_len =\n                5 + pubkey_packed_len + privkey_packed_trits_len;\n        }\n    }\n    \n    return;\n}\n\n\n/* ntru_crypto_ntru_encrypt_key_create_pubkey_blob\n *\n * Returns a public key blob, packed according to the packing type provided.\n */\n\nuint32_t\nntru_crypto_ntru_encrypt_key_create_pubkey_blob(\n    NTRU_ENCRYPT_PARAM_SET const *params,             /*  in - pointer to\n                                                               param set\n                                                               parameters */\n    uint16_t const               *pubkey,             /*  in - pointer to the\n                                                               coefficients\n                                                               of the pubkey */\n    uint8_t                       pubkey_pack_type,   /* out - pubkey packing\n                                                               type */\n    uint8_t                      *pubkey_blob)        /* out - addr for the\n                                                               pubkey blob */\n{\n\n    switch (pubkey_pack_type)\n    {\n        case NTRU_ENCRYPT_KEY_PACKED_COEFFICIENTS:\n            *pubkey_blob++ = NTRU_ENCRYPT_PUBKEY_TAG;\n            *pubkey_blob++ = (uint8_t)sizeof(params->OID);\n            memcpy(pubkey_blob, params->OID, sizeof(params->OID));\n            pubkey_blob += sizeof(params->OID);\n            ntru_elements_2_octets(params->N, pubkey, params->q_bits,\n                                   pubkey_blob);\n            break;\n\n        default:\n            NTRU_RET(NTRU_BAD_PARAMETER);\n    }\n\n    NTRU_RET(NTRU_OK);\n}\n\n\n/* ntru_crypto_ntru_encrypt_key_recreate_pubkey_blob\n *\n * Returns a public key blob, recreated from an already-packed public key.\n */\n\nuint32_t\nntru_crypto_ntru_encrypt_key_recreate_pubkey_blob(\n    NTRU_ENCRYPT_PARAM_SET const *params,             /*  in - pointer to\n                                                               param set\n                                                               parameters */\n    uint16_t                      packed_pubkey_len,  /*  in - no. octets in\n                                                               packed pubkey */\n    uint8_t const                *packed_pubkey,      /*  in - pointer to the\n                                                               packed pubkey */\n    uint8_t                       pubkey_pack_type,   /* out - pubkey packing\n                                                               type */\n    uint8_t                      *pubkey_blob)        /* out - addr for the\n                                                               pubkey blob */\n{\n\n    switch (pubkey_pack_type)\n    {\n        case NTRU_ENCRYPT_KEY_PACKED_COEFFICIENTS:\n            *pubkey_blob++ = NTRU_ENCRYPT_PUBKEY_TAG;\n            *pubkey_blob++ = (uint8_t)sizeof(params->OID);\n            memcpy(pubkey_blob, params->OID, sizeof(params->OID));\n            pubkey_blob += sizeof(params->OID);\n            memcpy(pubkey_blob, packed_pubkey, packed_pubkey_len);\n            break;\n\n        default:\n            NTRU_RET(NTRU_BAD_PARAMETER);\n    }\n\n    NTRU_RET(NTRU_OK);\n}\n\n\n/* ntru_crypto_ntru_encrypt_key_create_privkey_blob\n *\n * Returns a private key blob, packed according to the packing type provided.\n */\n\nuint32_t\nntru_crypto_ntru_encrypt_key_create_privkey_blob(\n    NTRU_ENCRYPT_PARAM_SET const *params,             /*  in - pointer to\n                                                               param set\n                                                               parameters */\n    uint16_t const               *pubkey,             /*  in - pointer to the\n                                                               coefficients\n                                                               of the pubkey */\n    uint16_t const               *privkey,            /*  in - pointer to the\n                                                               indices of the\n                                                               privkey */\n    uint8_t                       privkey_pack_type,  /*  in - privkey packing\n                                                               type */\n    uint8_t                      *buf,                /*  in - temp, N bytes */\n    uint8_t                      *privkey_blob)       /* out - addr for the\n                                                               privkey blob */\n{\n    switch (privkey_pack_type)\n    {\n        case NTRU_ENCRYPT_KEY_PACKED_TRITS:\n        case NTRU_ENCRYPT_KEY_PACKED_INDICES:\n\n            /* format header and packed public key */\n\n            *privkey_blob++ = NTRU_ENCRYPT_PRIVKEY_DEFAULT_TAG;\n            *privkey_blob++ = (uint8_t)sizeof(params->OID);\n            memcpy(privkey_blob, params->OID, sizeof(params->OID));\n            privkey_blob += sizeof(params->OID);\n            ntru_elements_2_octets(params->N, pubkey, params->q_bits,\n                                   privkey_blob);\n            privkey_blob += (params->N * params->q_bits + 7) >> 3;\n\n            /* add packed private key */\n\n            if (privkey_pack_type == NTRU_ENCRYPT_KEY_PACKED_TRITS)\n            {\n                ntru_indices_2_packed_trits(privkey, (uint16_t)params->dF_r,\n                                            (uint16_t)params->dF_r,\n                                            params->N, buf, privkey_blob);\n            }\n            else\n            {\n                uint32_t dF;\n\n                if (params->is_product_form)\n                {\n                    dF =  (params->dF_r & 0xff) +\n                         ((params->dF_r >> 8) & 0xff) +\n                         ((params->dF_r >> 16) & 0xff);\n                }\n                else\n                {\n                    dF = params->dF_r;\n                }\n                \n                ntru_elements_2_octets((uint16_t)dF << 1, privkey,\n                                       params->N_bits, privkey_blob);\n            }\n            break;\n            \n        default:\n            NTRU_RET(NTRU_BAD_PARAMETER);\n    }\n    \n    NTRU_RET(NTRU_OK);\n}\n\n\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_ntru_param_sets.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File: ntru_crypto_ntru_encrypt_param_sets.c\n *\n * Contents: Defines the NTRUEncrypt parameter sets.\n *\n *****************************************************************************/\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_ntru_encrypt_param_sets.h\"\n\n\n/* parameter sets */\n\nstatic NTRU_ENCRYPT_PARAM_SET ntruParamSets[] = {\n\n    {\n        NTRU_EES401EP1,              /* parameter-set id */\n        \"ees401ep1\",                 /* human readable param set name */\n        {0x00, 0x02, 0x04},          /* OID */\n        0x22,                        /* DER id */\n        9,                           /* no. of bits in N (i.e., in an index) */\n        401,                         /* N */\n        14,                          /* security strength in octets */\n        14,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        113,                         /* df, dr */\n        133,                         /* dg */\n        60,                          /* maxMsgLenBytes */\n        113,                         /* dm0 */\n        2005,                        /* 2^c - (2^c mod N) */\n        11,                          /* c */\n        1,                           /* lLen */\n        41,                          /* min. no. of hash calls for IGF-2 */\n        7,                           /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA1, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES449EP1,              /* parameter-set id */\n        \"ees449ep1\",                 /* human readable param set name */\n        {0x00, 0x03, 0x03},          /* OID */\n        0x23,                        /* DER id */\n        9,                           /* no. of bits in N (i.e., in an index) */\n        449,                         /* N */\n        16,                          /* security strength in octets */\n        16,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        134,                         /* df, dr */\n        149,                         /* dg */\n        67,                          /* maxMsgLenBytes */\n        134,                         /* dm0 */\n        449,                         /* 2^c - (2^c mod N) */\n        9,                           /* c */\n        1,                           /* lLen */\n        47,                          /* min. no. of hash calls for IGF-2 */\n        8,                           /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA1, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES677EP1,              /* parameter-set id */\n        \"ees677ep1\",                 /* human readable param set name */\n        {0x00, 0x05, 0x03},          /* OID */\n        0x24,                        /* DER id */\n        10,                          /* no. of bits in N (i.e., in an index) */\n        677,                         /* N */\n        24,                          /* security strength in octets */\n        24,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        157,                         /* df, dr */\n        225,                         /* dg */\n        101,                         /* maxMsgLenBytes */\n        157,                         /* dm0 */\n        2031,                        /* 2^c - (2^c mod N) */\n        11,                          /* c */\n        1,                           /* lLen */\n        32,                          /* min. no. of hash calls for IGF-2 */\n        8,                           /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA256, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES1087EP2,             /* parameter-set id */\n        \"ees1087ep2\",                /* human readable param set name */\n        {0x00, 0x06, 0x03},          /* OID */\n        0x25,                        /* DER id */\n        11,                          /* no. of bits in N (i.e., in an index) */\n        1087,                        /* N */\n        32,                          /* security strength in octets */\n        32,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        120,                         /* df, dr */\n        362,                         /* dg */\n        170,                         /* maxMsgLenBytes */\n        120,                         /* dm0 */\n        7609,                        /* 2^c - (2^c mod N) */\n        13,                          /* c */\n        1,                           /* lLen */\n        27,                          /* min. no. of hash calls for IGF-2 */\n        11,                          /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA256, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES541EP1,              /* parameter-set id */\n        \"ees541ep1\",                 /* human readable param set name */\n        {0x00, 0x02, 0x05},          /* OID */\n        0x26,                        /* DER id */\n        10,                          /* no. of bits in N (i.e., in an index) */\n        541,                         /* N */\n        14,                          /* security strength in octets */\n        14,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        49,                          /* df, dr */\n        180,                         /* dg */\n        86,                          /* maxMsgLenBytes */\n        49,                          /* dm0 */\n        3787,                        /* 2^c - (2^c mod N) */\n        12,                          /* c */\n        1,                           /* lLen */\n        16,                          /* min. no. of hash calls for IGF-2 */\n        9,                          /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA1, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES613EP1,              /* parameter-set id */\n        \"ees613ep1\",                 /* human readable param set name */\n        {0x00, 0x03, 0x04},          /* OID */\n        0x27,                        /* DER id */\n        10,                          /* no. of bits in N (i.e., in an index) */\n        613,                         /* N */\n        16,                          /* securuity strength in octets */\n        16,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        55,                          /* df, dr */\n        204,                         /* dg */\n        97,                          /* maxMsgLenBytes */\n        55,                          /* dm0 */\n        1839,                        /* 2^c - (2^c mod N) */\n        11,                          /* c */\n        1,                           /* lLen */\n        18,                          /* min. no. of hash calls for IGF-2 */\n        10,                          /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA1, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES887EP1,              /* parameter-set id */\n        \"ees887ep1\",                 /* human readable param set name */\n        {0x00, 0x05, 0x04},          /* OID */\n        0x28,                        /* DER id */\n        10,                          /* no. of bits in N (i.e., in an index) */\n        887,                         /* N */\n        24,                          /* security strength in octets */\n        24,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        81,                          /* df, dr */\n        295,                         /* dg */\n        141,                         /* maxMsgLenBytes */\n        81,                          /* dm0 */\n        887,                         /* 2^c - (2^c mod N) */\n        10,                          /* c */\n        1,                           /* lLen */\n        16,                          /* min. no. of hash calls for IGF-2 */\n        9,                          /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA256, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES1171EP1,             /* parameter-set id */\n        \"ees1171ep1\",                /* human readable param set name */\n        {0x00, 0x06, 0x04},          /* OID */\n        0x29,                        /* DER id */\n        11,                          /* no. of bits in N (i.e., in an index) */\n        1171,                        /* N */\n        32,                          /* security strength in octets */\n        32,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        106,                         /* df, dr */\n        390,                         /* dg */\n        186,                         /* maxMsgLenBytes */\n        106,                         /* dm0 */\n        3513,                        /* 2^c - (2^c mod N) */\n        12,                          /* c */\n        1,                           /* lLen */\n        25,                          /* min. no. of hash calls for IGF-2 */\n        12,                          /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA256, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES659EP1,              /* parameter-set id */\n        \"ees659ep1\",                 /* human readable param set name */\n        {0x00, 0x02, 0x06},          /* OID */\n        0x2a,                        /* DER id */\n        10,                          /* no. of bits in N (i.e., in an index) */\n        659,                         /* N */\n        14,                          /* security strength in octets */\n        14,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        38,                          /* df, dr */\n        219,                         /* dg */\n        108,                         /* maxMsgLenBytes */\n        38,                          /* dm0 */\n        1977,                        /* 2^c - (2^c mod N) */\n        11,                          /* c */\n        1,                           /* lLen */\n        11,                          /* min. no. of hash calls for IGF-2 */\n        10,                          /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA1, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES761EP1,              /* parameter-set id */\n        \"ees761ep1\",                 /* human readable param set name */\n        {0x00, 0x03, 0x05},          /* OID */\n        0x2b,                        /* DER id */\n        10,                          /* no. of bits in N (i.e., in an index) */\n        761,                         /* N */\n        16,                          /* security strength in octets */\n        16,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        42,                          /* df, dr */\n        253,                         /* dg */\n        125,                         /* maxMsgLenBytes */\n        42,                          /* dm0 */\n        3805,                        /* 2^c - (2^c mod N) */\n        12,                          /* c */\n        1,                           /* lLen */\n        14,                          /* min. no. of hash calls for IGF-2 */\n        12,                          /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA1, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES1087EP1,             /* parameter-set id */\n        \"ees1087ep1\",                /* human readable param set name */\n        {0x00, 0x05, 0x05},          /* OID */\n        0x2c,                        /* DER id */\n        11,                          /* no. of bits in N (i.e., in an index) */\n        1087,                        /* N */\n        24,                          /* security strength in octets */\n        24,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        63,                          /* df, dr */\n        362,                         /* dg */\n        178,                         /* maxMsgLenBytes */\n        63,                          /* dm0 */\n        7609,                        /* 2^c - (2^c mod N) */\n        13,                          /* c */\n        1,                           /* lLen */\n        14,                          /* min. no. of hash calls for IGF-2 */\n        11,                          /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA256, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES1499EP1,             /* parameter-set id */\n        \"ees1499ep1\",                /* human readable param set name */\n        {0x00, 0x06, 0x05},          /* OID */\n        0x2d,                        /* DER id */\n        11,                          /* no. of bits in N (i.e., in an index) */\n        1499,                        /* N */\n        32,                          /* security strength in octets */\n        32,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        FALSE,                       /* product form */\n        79,                          /* df, dr */\n        499,                         /* dg */\n        247,                         /* maxMsgLenBytes */\n        79,                          /* dm0 */\n        7495,                        /* 2^c - (2^c mod N) */\n        13,                          /* c */\n        1,                           /* lLen */\n        18,                          /* min. no. of hash calls for IGF-2 */\n        14,                          /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA256, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES401EP2,              /* parameter-set id */\n        \"ees401ep2\",                 /* human readable param set name */\n        {0x00, 0x02, 0x10},          /* OID */\n        0x2e,                        /* DER id */\n        9,                           /* no. of bits in N (i.e., in an index) */\n        401,                         /* N */\n        14,                          /* security strength in octets */\n        14,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        TRUE,                        /* product form */\n        8 + (8 << 8) + (6 << 16),    /* df, dr */\n        133,                         /* dg */\n        60,                          /* maxMsgLenBytes */\n        101,                         /* dm0 */\n        2005,                        /* 2^c - (2^c mod N) */\n        11,                          /* c */\n        1,                           /* lLen */\n        7,                           /* min. no. of hash calls for IGF-2 */\n        7,                           /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA1, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES439EP1,              /* parameter-set id */\n        \"ees439ep1\",                 /* human readable param set name */\n        {0x00, 0x03, 0x10},          /* OID */\n        0x2f,                        /* DER id */\n        9,                           /* no. of bits in N (i.e., in an index) */\n        439,                         /* N */\n        16,                          /* security strength in octets */\n        16,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        TRUE,                        /* product form */\n        9 + (8 << 8) + (5 << 16),    /* df, dr */\n        146,                         /* dg */\n        65,                          /* maxMsgLenBytes */\n        112,                         /* dm0 */\n        439,                         /* 2^c - (2^c mod N) */\n        9,                           /* c */\n        1,                           /* lLen */\n        8,                           /* min. no. of hash calls for IGF-2 */\n        8,                           /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA1, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES593EP1,              /* parameter-set id */\n        \"ees593ep1\",                 /* human readable param set name */\n        {0x00, 0x05, 0x10},          /* OID */\n        0x30,                        /* DER id */\n        10,                          /* no. of bits in N (i.e., in an index) */\n        593,                         /* N */\n        24,                          /* security strength in octets */\n        24,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        TRUE,                        /* product form */\n        10 + (10 << 8) + (8 << 16),  /* df, dr */\n        197,                         /* dg */\n        86,                          /* maxMsgLenBytes */\n        158,                         /* dm0 */\n        1779,                        /* 2^c - (2^c mod N) */\n        11,                          /* c */\n        1,                           /* lLen */\n        9,                           /* min. no. of hash calls for IGF-2 */\n        7,                           /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA256, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES743EP1,              /* parameter-set id */\n        \"ees743ep1\",                 /* human readable param set name */\n        {0x00, 0x06, 0x10},          /* OID */\n        0x31,                        /* DER id */\n        10,                          /* no. of bits in N (i.e., in an index) */\n        743,                         /* N */\n        32,                          /* security strength in octets */\n        32,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        TRUE,                        /* product form */\n        11 + (11 << 8) + (15 << 16), /* df, dr */\n        247,                         /* dg */\n        106,                         /* maxMsgLenBytes */\n        204,                         /* dm0 */\n        8173,                        /* 2^c - (2^c mod N) */\n        13,                          /* c */\n        1,                           /* lLen */\n        9,                           /* min. no. of hash calls for IGF-2 */\n        9,                           /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA256, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES443EP1,              /* parameter-set id */\n        \"ees443ep1\",                 /* human readable param set name */\n        {0x00, 0x03, 0x11},          /* OID */\n        0x32,                        /* DER id */\n        9,                           /* no. of bits in N (i.e., in an index) */\n        443,                         /* N */\n        16,                          /* security strength in octets */\n        32,                          /* no. of octets for random string b */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        TRUE,                        /* product form */\n        9 + (8 << 8) + (5 << 16),    /* df, dr */\n        148,                         /* dg */\n        49,                          /* maxMsgLenBytes */\n        115,                         /* dm0 */\n        443,                         /* 2^c - (2^c mod N) */\n        9,                           /* c */\n        1,                           /* lLen */\n        5,                           /* min. no. of hash calls for IGF-2 */\n        5,                           /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA256, /* hash function for MGF-TP-1,\n                                        HMAC-DRBG, etc. */\n    },\n\n    {\n        NTRU_EES587EP1,              /* parameter-set id */\n        \"ees587ep1\",                 /* human readable param set name */\n        {0x00, 0x05, 0x11},          /* OID */\n        0x33,                        /* DER id */\n        10,                          /* no. of bits in N (i.e., in an index) */\n        587,                         /* N */\n        24,                          /* security strength in octets */\n        32,                          /* no. of octets for random string b  */\n        2048,                        /* q */\n        11,                          /* no. of bits in q (i.e., in a coeff) */\n        TRUE,                        /* product form */\n        10 + (10 << 8) + (8 << 16),  /* df, dr */\n        196,                         /* dg */\n        76,                          /* maxMsgLenBytes */\n        157,                         /* dm0 */\n        1761,                        /* 2^c - (2^c mod N) */\n        11,                          /* c */\n        1,                           /* lLen */\n        7,                          /* min. no. of hash calls for IGF-2 */\n        7,                           /* min. no. of hash calls for MGF-TP-1 */\n        NTRU_CRYPTO_HASH_ALGID_SHA256,  /* hash function for MGF-TP-1,\n                                           HMAC-DRBG, etc. */\n    },\n};\n\nstatic size_t numParamSets =\n                sizeof(ntruParamSets)/sizeof(NTRU_ENCRYPT_PARAM_SET);\n\n\n/* functions */\n\n/* ntru_encrypt_get_params_with_id\n *\n * Looks up a set of NTRUEncrypt parameters based on the id of the\n * parameter set.\n *\n * Returns a pointer to the parameter set parameters if successful.\n * Returns NULL if the parameter set cannot be found.\n */\n\nNTRU_ENCRYPT_PARAM_SET *\nntru_encrypt_get_params_with_id(\n    NTRU_ENCRYPT_PARAM_SET_ID id)   /*  in - parameter-set id */\n{\n    size_t i;\n\n    for (i = 0; i < numParamSets; i++)\n    {\n        if (ntruParamSets[i].id == id)\n        {\n            return &(ntruParamSets[i]);\n        }\n    }\n    \n    return NULL;\n}\n\n\n/* ntru_encrypt_get_params_with_OID\n *\n * Looks up a set of NTRUEncrypt parameters based on the OID of the\n * parameter set.\n *\n * Returns a pointer to the parameter set parameters if successful.\n * Returns NULL if the parameter set cannot be found.\n */\n\nNTRU_ENCRYPT_PARAM_SET *\nntru_encrypt_get_params_with_OID(\n    uint8_t const *oid)             /*  in - pointer to parameter-set OID */\n{\n    size_t i;\n\n    for (i = 0; i < numParamSets; i++)\n    {\n        if (!memcmp(ntruParamSets[i].OID, oid, 3))\n        {\n            return &(ntruParamSets[i]);\n        }\n    }\n    \n    return NULL;\n}\n\n\n/* ntru_encrypt_get_params_with_DER_id\n *\n * Looks up a set of NTRUEncrypt parameters based on the DER id of the\n * parameter set.\n *\n * Returns a pointer to the parameter set parameters if successful.\n * Returns NULL if the parameter set cannot be found.\n */\n\nNTRU_ENCRYPT_PARAM_SET *\nntru_encrypt_get_params_with_DER_id(\n    uint8_t der_id)                 /*  in - parameter-set DER id */\n{\n    size_t i;\n\n    for (i = 0; i < numParamSets; i++)\n    {\n        if (ntruParamSets[i].der_id == der_id)\n        {\n            return &(ntruParamSets[i]);\n        }\n    }\n    return NULL;\n}\n\n\nconst char*\nntru_encrypt_get_param_set_name(\n    NTRU_ENCRYPT_PARAM_SET_ID id)   /*  in - parameter-set id */\n{\n    size_t i;\n\n    for (i = 0; i < numParamSets; i++)\n    {\n        if (ntruParamSets[i].id == id)\n        {\n            return ntruParamSets[i].name;\n        }\n    }\n\n    return NULL;\n}\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_ntru_mgf1.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File: ntru_crypto_ntru_mgf1.c\n *\n * Contents: Routines implementing MGF-TP-1 and MGF-1.\n *\n *****************************************************************************/\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_ntru_mgf1.h\"\n#include \"ntru_crypto_ntru_convert.h\"\n\n\n/* ntru_mgf1\n *\n * Implements a basic mask-generation function, generating an arbitrary\n * number of octets based on hashing a digest-length string concatenated\n * with a 4-octet counter.\n *\n * The state (string and counter) is initialized when a seed is present.\n *\n * Returns NTRU_OK if successful.\n * Returns NTRU_CRYPTO_HASH_ errors if they occur.\n *\n */\n\nuint32_t\nntru_mgf1(\n    uint8_t                *state,      /* in/out - pointer to the state */\n    NTRU_CRYPTO_HASH_ALGID  algid,      /*     in - hash algorithm ID */\n    uint8_t                 md_len,     /*     in - no. of octets in digest */\n    uint8_t                 num_calls,  /*     in - no. of hash calls */\n    uint16_t                seed_len,   /*     in - no. of octets in seed */\n    uint8_t const          *seed,       /*     in - pointer to seed */\n    uint8_t                *out)        /*    out - address for output */\n{\n    uint8_t  *ctr = state + md_len;\n    uint32_t  retcode;\n\n    /* if seed present, init state */\n\n    if (seed)\n    {\n        if ((retcode = ntru_crypto_hash_digest(algid, seed, seed_len, state)) !=\n                NTRU_CRYPTO_HASH_OK)\n        {\n            return retcode;\n        }\n        \n        memset(ctr, 0, 4);\n    }\n\n    /* generate output */\n\n    while (num_calls-- > 0)\n    {\n        if ((retcode = ntru_crypto_hash_digest(algid, state, md_len + 4,\n                     out)) != NTRU_CRYPTO_HASH_OK)\n        {\n            return retcode;\n        }\n        \n        out += md_len;\n\n        /* increment counter */\n\n        if (++ctr[3] == 0)\n        {\n            if (++ctr[2] == 0)\n            {\n                if (++ctr[1] == 0)\n                {\n                    ++ctr[0];\n                }\n            }\n        }\n    }\n\n    NTRU_RET(NTRU_OK);\n}\n\n\n/* ntru_mgftp1\n *\n * Implements a mask-generation function for trinary polynomials,\n * MGF-TP-1, generating an arbitrary number of octets based on hashing\n * a digest-length string concatenated with a 4-octet counter.  From\n * these octets, N trits are derived.\n *\n * The state (string and counter) is initialized when a seed is present.\n *\n * Returns NTRU_OK if successful.\n * Returns NTRU_CRYPTO_HASH_ errors if they occur.\n *\n */\n\nuint32_t\nntru_mgftp1(\n    NTRU_CRYPTO_HASH_ALGID  hash_algid,       /*  in - hash alg ID for\n                                                       MGF-TP-1 */\n    uint8_t                 md_len,           /*  in - no. of octets in\n                                                       digest */\n    uint8_t                 min_calls,        /*  in - minimum no. of hash\n                                                       calls */\n    uint16_t                seed_len,         /*  in - no. of octets in seed */\n    uint8_t                *seed,             /*  in - pointer to seed */\n    uint8_t                *buf,              /*  in - pointer to working\n                                                       buffer */\n    uint16_t                num_trits_needed, /*  in - no. of trits in mask */\n    uint8_t                *mask)             /* out - address for mask trits */\n{\n    uint8_t  *mgf_out;\n    uint8_t  *octets;\n    uint16_t  octets_available;\n    uint32_t  retcode;\n\n    /* generate minimum MGF1 output */\n\n    mgf_out = buf + md_len + 4;\n    if ((retcode = ntru_mgf1(buf, hash_algid, md_len, min_calls,\n                             seed_len, seed, mgf_out)) != NTRU_OK)\n    {\n        return retcode;\n    }\n    \n    octets = mgf_out;\n    octets_available = min_calls * md_len;\n\n    /* get trits for mask */\n\n    while (num_trits_needed >= 5)\n    {\n        /* get another octet and convert it to 5 trits */\n\n        if (octets_available == 0)\n        {\n            if ((retcode = ntru_mgf1(buf, hash_algid, md_len, 1,\n                                     0, NULL, mgf_out)) != NTRU_OK)\n            {\n                return retcode;\n            }\n            \n            octets = mgf_out;\n            octets_available = md_len;\n        }\n\n        if (*octets < 243)\n        {\n            ntru_octet_2_trits(*octets, mask);\n            mask += 5;\n            num_trits_needed -= 5;\n        }\n        \n        octets++;\n        --octets_available;\n    }\n\n    /* get any remaining trits */\n\n    while (num_trits_needed)\n    {\n        uint8_t trits[5];\n\n        /* get another octet and convert it to remaining trits */\n\n        if (octets_available == 0)\n        {\n            if ((retcode = ntru_mgf1(buf, hash_algid, md_len, 1,\n                                     0, NULL, mgf_out)) != NTRU_OK)\n            {\n                return retcode;\n            }\n            \n            octets = mgf_out;\n            octets_available = md_len;\n        }\n        \n        if (*octets < 243)\n        {\n            ntru_octet_2_trits(*octets, trits);\n            memcpy(mask, trits, num_trits_needed);\n            num_trits_needed = 0;\n        }\n        else\n        {\n            octets++;\n            --octets_available;\n        }\n    }\n\n    NTRU_RET(NTRU_OK);\n}\n\n\n","#include \"ntru_crypto.h\"\n#include \"ntru_crypto_ntru_poly.h\"\n\n#define PAD(N) ((N + 0x000f) & 0xfff0)\n\nstatic void\ngrade_school_mul(\n    uint16_t        *res1,  /* out - a * b in Z[x], must be length 2N */\n    uint16_t const  *a,     /*  in - polynomial */\n    uint16_t const  *b,     /*  in - polynomial */\n    uint16_t const   N)     /*  in - number of coefficients in a and b */\n{\n    uint16_t i;\n    uint16_t j;\n\n    for(j=0; j<N; j++)\n    {\n        res1[j] = a[0]*b[j];\n    }\n    for(i=1; i<N; i++)\n    {\n        res1[i+N-1] = 0;\n        for(j=0; j<N; j++)\n        {\n            res1[i+j] += a[i]*b[j];\n        }\n    }\n    res1[2*N-1] = 0;\n\n    return;\n}\n\nstatic void\nkaratsuba(\n    uint16_t        *res1,  /* out - a * b in Z[x], must be length 2k */\n    uint16_t        *tmp1,  /*  in - k coefficients of scratch space */\n    uint16_t const  *a,     /*  in - polynomial */\n    uint16_t const  *b,     /*  in - polynomial */\n    uint16_t const   k)     /*  in - number of coefficients in a and b */\n{\n    uint16_t i;\n\n    uint16_t const p = k>>1;\n\n    uint16_t *res2;\n    uint16_t *res3;\n    uint16_t *res4;\n    uint16_t *tmp2;\n    uint16_t const *a2;\n    uint16_t const *b2;\n\n\n    /* Grade school multiplication for small / odd inputs */\n    if(k <= 38 || (k & 1) != 0)\n    {\n      grade_school_mul(res1,a,b,k);\n      return;\n    }\n\n    res2 = res1+p;\n    res3 = res1+k;\n    res4 = res1+k+p;\n    tmp2 = tmp1+p;\n    a2 = a+p;\n    b2 = b+p;\n\n    for(i=0; i<p; i++)\n    {\n        res1[i] = a[i] - a2[i];\n        res2[i] = b2[i] - b[i];\n    }\n\n    karatsuba(tmp1, res3, res1, res2, p);\n\n    karatsuba(res3, res1, a2, b2, p);\n\n    for(i=0; i<p; i++)\n    {\n      tmp1[i] += res3[i];\n    }\n\n    for(i=0; i<p; i++)\n    {\n        res2[i]  = tmp1[i];\n        tmp2[i] += res4[i];\n        res3[i] += tmp2[i];\n    }\n\n    karatsuba(tmp1, res1, a, b, p);\n\n    for(i=0; i<p; i++)\n    {\n        res1[i]  = tmp1[i];\n        res2[i] += tmp1[i] + tmp2[i];\n        res3[i] += tmp2[i];\n    }\n\n    return;\n}\n\n\nvoid\nntru_ring_mult_coefficients_memreq(\n    uint16_t N,\n    uint16_t *tmp_polys,\n    uint16_t *poly_coeffs)\n{\n    if(tmp_polys)\n    {\n        *tmp_polys= 3;\n    }\n\n    if(poly_coeffs)\n    {\n        *poly_coeffs = PAD(N);\n    }\n}\n\n/* ntru_ring_mult_coefficients\n *\n * Multiplies ring element (polynomial) \"a\" by ring element (polynomial) \"b\"\n * to produce ring element (polynomial) \"c\" in (Z/qZ)[X]/(X^N - 1).\n * This is a convolution operation.\n *\n * This assumes q is 2^r where 8 < r < 16, so that overflow of the sum\n * beyond 16 bits does not matter.\n */\n\nvoid\nntru_ring_mult_coefficients(\n    uint16_t const *a,          /*  in - pointer to polynomial a */\n    uint16_t const *b,          /*  in - pointer to polynomial b */\n    uint16_t        N,          /*  in - degree of (x^N - 1) */\n    uint16_t        q,          /*  in - large modulus */\n    uint16_t       *tmp,        /*  in - temp buffer of 3*padN elements */\n    uint16_t       *c)          /* out - address for polynomial c */\n{\n    uint16_t i;\n    uint16_t q_mask = q-1;\n\n    memset(tmp, 0, 3*PAD(N)*sizeof(uint16_t));\n    karatsuba(tmp, tmp+2*PAD(N), a, b, PAD(N));\n\n    for(i=0; i<N; i++)\n    {\n        c[i] = (tmp[i] + tmp[i+N]) & q_mask;\n    }\n    for(; i<PAD(N); i++)\n    {\n        c[i] = 0;\n    }\n\n    return;\n}\n","#include \"ntru_crypto.h\"\n#include \"ntru_crypto_ntru_poly.h\"\n\n\nvoid\nntru_ring_mult_indices_memreq(\n    uint16_t N,\n    uint16_t *tmp_polys,\n    uint16_t *poly_coeffs)\n{\n    if(tmp_polys)\n    {\n        *tmp_polys= 1;\n    }\n\n    if(poly_coeffs)\n    {\n        *poly_coeffs = N;\n    }\n}\n\n/* ntru_ring_mult_indices\n *\n * Multiplies ring element (polynomial) \"a\" by ring element (polynomial) \"b\"\n * to produce ring element (polynomial) \"c\" in (Z/qZ)[X]/(X^N - 1).\n * This is a convolution operation.\n *\n * Ring element \"b\" is a sparse trinary polynomial with coefficients -1, 0,\n * and 1.  It is specified by a list, bi, of its nonzero indices containing\n * indices for the bi_P1_len +1 coefficients followed by the indices for the\n * bi_M1_len -1 coefficients.\n * The indices are in the range [0,N).\n *\n * The result array \"c\" may share the same memory space as input array \"a\",\n * input array \"b\", or temp array \"t\".\n *\n * This assumes q is 2^r where 8 < r < 16, so that overflow of the sum\n * beyond 16 bits does not matter.\n */\n\nvoid\nntru_ring_mult_indices(\n    uint16_t const *a,          /*  in - pointer to ring element a */\n    uint16_t const  bi_P1_len,  /*  in - no. of +1 coefficients in b */\n    uint16_t const  bi_M1_len,  /*  in - no. of -1 coefficients in b */\n    uint16_t const *bi,         /*  in - pointer to the list of nonzero\n                                         indices of ring element b,\n                                         containing indices for the +1\n                                         coefficients followed by the\n                                         indices for -1 coefficients */\n    uint16_t const  N,          /*  in - no. of coefficients in a, b, c */\n    uint16_t const  q,          /*  in - large modulus */\n    uint16_t       *t,          /*  in - temp buffer of N elements */\n    uint16_t       *c)          /* out - address for polynomial c */\n{\n    uint16_t mod_q_mask = q - 1;\n    uint16_t i, j, k;\n\n    /* t[(i+k)%N] = sum i=0 through N-1 of a[i], for b[k] = -1 */\n\n    for (k = 0; k < N; k++)\n    {\n        t[k] = 0;\n    }\n\n    for (j = bi_P1_len; j < bi_P1_len + bi_M1_len; j++)\n    {\n        k = bi[j];\n\n        for (i = 0; k < N; ++i, ++k)\n        {\n            t[k] = t[k] + a[i];\n        }\n\n        for (k = 0; i < N; ++i, ++k)\n        {\n            t[k] = t[k] + a[i];\n        }\n    }\n\n    /* t[(i+k)%N] = -(sum i=0 through N-1 of a[i] for b[k] = -1) */\n\n    for (k = 0; k < N; k++)\n    {\n        t[k] = -t[k];\n    }\n\n    /* t[(i+k)%N] += sum i=0 through N-1 of a[i] for b[k] = +1 */\n\n    for (j = 0; j < bi_P1_len; j++)\n    {\n        k = bi[j];\n\n        for (i = 0; k < N; ++i, ++k)\n        {\n            t[k] = t[k] + a[i];\n        }\n\n        for (k = 0; i < N; ++i, ++k)\n        {\n            t[k] = t[k] + a[i];\n        }\n    }\n\n    /* c = (a * b) mod q */\n\n    for (k = 0; k < N; k++)\n    {\n        c[k] = t[k] & mod_q_mask;\n    }\n\n    return;\n}\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_ntru_poly.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n\n\n/******************************************************************************\n *\n * File: ntru_crypto_ntru_poly.c\n *\n * Contents: Routines for generating and operating on polynomials in the\n *           NTRU algorithm.\n *\n *****************************************************************************/\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_ntru_poly.h\"\n#include \"ntru_crypto_ntru_mgf1.h\"\n\n\n/* ntru_gen_poly\n *\n * Generates polynomials by creating for each polynomial, a list of the\n * indices of the +1 coefficients followed by a list of the indices of\n * the -1 coefficients.\n *\n * If a single polynomial is generated (non-product form), indices_counts\n * contains a single value of the total number of indices (for +1 and -1\n * comefficients combined).\n *\n * If multiple polynomials are generated (for product form), their lists of\n * indices are sequentially stored in the indices buffer.  Each byte of\n * indices_counts contains the total number of indices (for +1 and -1\n * coefficients combined) for a single polynomial, beginning with the\n * low-order byte for the first polynomial.  The high-order byte is unused.\n *\n * Returns NTRU_OK if successful.\n * Returns HASH_BAD_ALG if the algorithm is not supported.\n *\n */\n\nuint32_t\nntru_gen_poly(\n    NTRU_CRYPTO_HASH_ALGID  hash_algid,      /*  in - hash algorithm ID for\n                                                      IGF-2 */\n    uint8_t                 md_len,          /*  in - no. of octets in digest */\n    uint8_t                 min_calls,       /*  in - minimum no. of hash\n                                                      calls */\n    uint16_t                seed_len,        /*  in - no. of octets in seed */\n    uint8_t                *seed,            /*  in - pointer to seed */\n    uint8_t                *buf,             /*  in - pointer to working\n                                                      buffer */\n    uint16_t                N,               /*  in - max index + 1 */\n    uint8_t                 c_bits,          /*  in - no. bits for candidate */\n    uint16_t                limit,           /*  in - conversion to index\n                                                      limit */\n    bool                    is_product_form, /*  in - if generating multiple\n                                                      polys */\n    uint32_t                indices_counts,  /*  in - nos. of indices needed */\n    uint16_t               *indices)         /* out - address for indices */\n{\n    uint8_t  *mgf_out;\n    uint8_t  *octets;\n    uint8_t  *used;\n    uint8_t   num_polys;\n    uint16_t  num_indices;\n    uint16_t  octets_available;\n    uint16_t  index_cnt = 0;\n    uint8_t   left = 0;\n    uint8_t   num_left = 0;\n    uint32_t  retcode;\n\n    /* generate minimum MGF1 output */\n\n    mgf_out = buf + md_len + 4;\n    if ((retcode = ntru_mgf1(buf, hash_algid, md_len, min_calls,\n                             seed_len, seed, mgf_out)) != NTRU_OK)\n    {\n        return retcode;\n    }\n\n    octets = mgf_out;\n    octets_available = min_calls * md_len;\n\n    /* init indices counts for number of polynomials being generated */\n\n    if (is_product_form)\n    {\n        /* number of indices for poly1 is in low byte of indices_counts,\n         * number of indices for poly2 and poly3 are in next higher bytes\n         */\n\n        num_polys = 3;\n        num_indices = (uint16_t)(indices_counts & 0xff);\n        indices_counts >>= 8;\n\n    }\n    else\n    {\n        /* number of bytes for poly is in low 16 bits of indices_counts */\n\n        num_polys = 1;\n        num_indices = (uint16_t)indices_counts;\n    }\n\n    /* init used-index array */\n\n    used = mgf_out + octets_available;\n    memset(used, 0, N);\n\n    /* generate indices (IGF-2) for all polynomials */\n\n    while (num_polys > 0)\n    {\n\n        /* generate indices for a single polynomial */\n\n        while (index_cnt < num_indices)\n        {\n            uint16_t index;\n            uint8_t  num_needed;\n\n            /* form next index to convert to an index */\n\n            do {\n                /* use any leftover bits first */\n\n                if (num_left != 0)\n                {\n                    index = left << (c_bits - num_left);\n                }\n                else\n                {\n                    index = 0;\n                }\n\n                /* get the rest of the bits needed from new octets */\n\n                num_needed = c_bits - num_left;\n                while (num_needed != 0)\n                {\n                    /* get another octet */\n\n                    if (octets_available == 0)\n                    {\n                        if ((retcode = ntru_mgf1(buf, hash_algid, md_len, 1,\n                                                 0, NULL, mgf_out)) != NTRU_OK)\n                        {\n                            return retcode;\n                        }\n                        \n                        octets = mgf_out;\n                        octets_available = md_len;\n                    }\n                    left = *octets++;\n                    --octets_available;\n\n                    if (num_needed <= 8)\n                    {\n                        /* all bits needed to fill the index are in this octet */\n\n                        index |= ((uint16_t)(left)) >> (8 - num_needed);\n                        num_left = 8 - num_needed;\n                        num_needed = 0;\n                        left &= 0xff >> (8 - num_left);\n\n                    }\n                    else\n                    {\n                        /* another octet will be needed after using this\n                         * whole octet\n                         */\n\n                        index |= ((uint16_t)left) << (num_needed - 8);\n                        num_needed -= 8;\n                    }\n                }\n            } while (index >= limit);\n\n            /* form index and check if unique */\n\n            index %= N;\n            \n            if (!used[index])\n            {\n                used[index] = 1;\n                indices[index_cnt] = index;\n                ++index_cnt;\n            }\n        }\n        --num_polys;\n\n        /* init for next polynomial if another polynomial to be generated */\n\n        if (num_polys > 0)\n        {\n            memset(used, 0, N);\n            num_indices = num_indices +\n                          (uint16_t)(indices_counts & 0xff);\n            indices_counts >>= 8;\n        }\n    }\n\n    NTRU_RET(NTRU_OK);\n}\n\n\n/* ntru_poly_check_min_weight\n *\n * Checks that the number of 0, +1, and -1 trinary ring elements meet or exceed\n * a minimum weight.\n */\n\nbool\nntru_poly_check_min_weight(\n    uint16_t  num_els,              /*  in - degree of polynomial */\n    uint8_t  *ringels,              /*  in - pointer to trinary ring elements */\n    uint16_t  min_wt)               /*  in - minimum weight */\n{\n    uint16_t wt[3];\n    uint16_t i;\n\n    wt[0] = wt[1] = wt[2] = 0;\n    \n    for (i = 0; i < num_els; i++)\n    {\n       ++wt[ringels[i]];\n    }\n    \n    if ((wt[0] < min_wt) || (wt[1] < min_wt) || (wt[2] < min_wt))\n    {\n        return FALSE;\n    }\n    \n    return TRUE;\n}\n\n\n/* ntru_ring_mult_product_indices\n *\n * Multiplies ring element (polynomial) \"a\" by ring element (polynomial) \"b\"\n * to produce ring element (polynomial) \"c\" in (Z/qZ)[X]/(X^N - 1).\n * This is a convolution operation.\n *\n * Ring element \"b\" is represented by the product form b1 * b2 + b3, where\n * b1, b2, and b3 are each a sparse trinary polynomial with coefficients -1,\n * 0, and 1.  It is specified by a list, bi, of the nonzero indices of b1, b2,\n * and b3, containing the indices for the +1 coefficients followed by the\n * indices for the -1 coefficients for each polynomial in that order.\n * The indices are in the range [0,N).\n *\n * The result array \"c\" may share the same memory space as input array \"a\",\n * or input array \"b\".\n *\n * This assumes q is 2^r where 8 < r < 16, so that overflow of the sum\n * beyond 16 bits does not matter.\n */\n\nvoid\nntru_ring_mult_product_indices(\n    uint16_t const *a,          /*  in - pointer to ring element a */\n    uint16_t const  b1i_len,    /*  in - no. of +1 or -1 coefficients in b1 */\n    uint16_t const  b2i_len,    /*  in - no. of +1 or -1 coefficients in b2 */\n    uint16_t const  b3i_len,    /*  in - no. of +1 or -1 coefficients in b3 */\n    uint16_t const *bi,         /*  in - pointer to the list of nonzero\n                                         indices of polynomials b1, b2, b3,\n                                         containing indices for the +1\n                                         coefficients followed by the\n                                         indices for -1 coefficients for\n                                         each polynomial */\n    uint16_t const  N,          /*  in - no. of coefficients in a, b, c */\n    uint16_t const  q,          /*  in - large modulus */\n    uint16_t       *t,          /*  in - temp buffer of 2N elements */\n    uint16_t       *c)          /* out - address for polynomial c */\n{\n    uint16_t scratch_polys;\n    uint16_t poly_coeffs;\n    uint16_t *t2;\n    uint16_t  mod_q_mask;\n    uint16_t  i;\n\n    ntru_ring_mult_indices_memreq(N, &scratch_polys, &poly_coeffs);\n    t2 = t + scratch_polys*poly_coeffs;\n    mod_q_mask = q - 1;\n\n    /* t2 = a * b1 */\n\n    ntru_ring_mult_indices(a, b1i_len, b1i_len, bi, N, q, t, t2);\n\n    /* t2 = (a * b1) * b2 */\n\n    ntru_ring_mult_indices(t2, b2i_len, b2i_len, bi + (b1i_len << 1), N, q,\n                           t, t2);\n\n    /* t = a * b3 */\n\n    ntru_ring_mult_indices(a, b3i_len, b3i_len,\n                           bi + ((b1i_len + b2i_len) << 1), N, q, t, t);\n\n    /* c = (a * b1 * b2) + (a * b3) */\n\n    for (i = 0; i < N; i++)\n    {\n        c[i] = (t2[i] + t[i]) & mod_q_mask;\n    }\n    for(; i<poly_coeffs; i++)\n    {\n        c[i] = 0;\n    }\n\n    return;\n}\n\n\n/* ntru_ring_inv\n *\n * Finds the inverse of a polynomial, a, in (Z/2Z)[X]/(X^N - 1).\n  */\n\nbool\nntru_ring_inv(\n    uint16_t       *a,          /*  in - pointer to polynomial a */\n    uint16_t        N,          /*  in - no. of coefficients in a */\n    uint16_t       *t,          /*  in - temp buffer of 2N elements */\n    uint16_t       *a_inv)      /* out - address for polynomial a^-1 */\n{\n    uint8_t  *b = (uint8_t *)t;     /* b cannot be in a_inv since it must be\n                                       rotated and copied there as a^-1 mod 2 */\n    uint8_t  *c = b + N;            /* c cannot be in a_inv since it exchanges\n                                       with b, and b cannot be in a_inv */\n    uint8_t  *f = c + N;\n    uint8_t  *g = (uint8_t *)a_inv; /* g needs N + 1 bytes */\n    uint16_t  deg_b;\n    uint16_t  deg_c;\n    uint16_t  deg_f;\n    uint16_t  deg_g;\n    uint16_t  k = 0;\n    uint16_t  i, j;\n\n    if (a == NULL || t == NULL || a_inv == NULL)\n    {\n        return FALSE;\n    }\n\n    /* form a^-1 in (Z/2Z)[X]/(X^N - 1) */\n\n    memset(b, 0, (N << 1));         /* clear to init b, c */\n\n    /* b(X) = 1 */\n\n    b[0] = 1;\n    deg_b = 0;\n\n    /* c(X) = 0 (cleared above) */\n\n    deg_c = 0;\n\n    /* f(X) = a(X) mod 2 */\n\n    deg_f = 0;\n    j = 0;\n    for (i = 0; i < N; i++)\n    {\n        f[i] = (uint8_t)(a[i] & 1);\n        j ^= f[i];\n        if(f[i]) deg_f = i;\n    }\n\n    /* Parity is zero, not invertible */\n    if(j == 0)\n    {\n      return FALSE;\n    }\n\n    /* g(X) = X^N - 1 */\n\n    g[0] = 1;\n    memset(g + 1, 0, N - 1);\n    g[N] = 1;\n    deg_g = N;\n\n    /* until f(X) = 1 */\n\n    while (1)\n    {\n        /* while f[0] = 0, f(X) /= X, c(X) *= X, k++ */\n\n        for (i = 0; (i <= deg_f) && (f[i] == 0); ++i);\n        if (i > deg_f)\n            return FALSE;\n        if (i) {\n            k = k + i;\n\n            f = f + i;\n            deg_f = deg_f - i;\n\n            memmove(c+i, c, deg_c+1);\n            memset(c, 0, i);\n            deg_c = deg_c + i;\n        }\n\n        /* if f(X) = 1, done */\n\n        if (deg_f == 0)\n        {\n            break;\n        }\n\n        /* if deg_f < deg_g, f <-> g, b <-> c */\n\n        if (deg_f < deg_g)\n        {\n            uint8_t *x;\n\n            x = f;\n            f = g;\n            g = x;\n            deg_f ^= deg_g;\n            deg_g ^= deg_f;\n            deg_f ^= deg_g;\n            x = b;\n            b = c;\n            c = x;\n            deg_b ^= deg_c;\n            deg_c ^= deg_b;\n            deg_b ^= deg_c;\n        }\n\n        /* f(X) += g(X)\n         * might change degree of f if deg_g >= deg_f\n         */\n        for (i=0; i<=deg_g; i++)\n        {\n            f[i] ^= g[i];\n        }\n\n        if(deg_g == deg_f)\n        {\n            while(deg_f > 0 && f[deg_f] == 0)\n            {\n                --deg_f;\n            }\n        }\n\n        /* b(X) += c(X) */\n        for (i=0; i<=deg_c; i++)\n        {\n            b[i] ^= c[i];\n        }\n\n        if (deg_c >= deg_b)\n        {\n            deg_b = deg_c;\n            while(deg_b > 0 && b[deg_b] == 0)\n            {\n                --deg_b;\n            }\n        }\n    }\n\n    /* a^-1 in (Z/2Z)[X]/(X^N - 1) = b(X) shifted left k coefficients */\n\n    j = 0;\n\n    if (k >= N)\n    {\n        k = k - N;\n    }\n\n    for (i = k; i < N; i++)\n    {\n        a_inv[j++] = (uint16_t)(b[i]);\n    }\n\n    for (i = 0; i < k; i++)\n    {\n        a_inv[j++] = (uint16_t)(b[i]);\n    }\n\n    return TRUE;\n}\n\n/* ntru_ring_lift_inv_pow2_product\n *\n * Lifts an element of (Z/2)[x]/(x^N - 1) to (Z/q)[x]/(x^N - 1)\n * where q is a power of 2 such that 256 < q <= 65536.\n *\n * inv must be padded with zeros to the degree used by\n * ntru_ring_mult_coefficients.\n *\n * inv is assumed to be the inverse mod 2 of the product form element\n * given by (1 + 3*(F1*F2 + F3)). The lift is performed in place --\n * inv will be overwritten with the result.\n *\n * Requires scratch space for ntru_ring_mult_coefficients + one extra\n * polynomial with the same padding.\n */\nuint32_t\nntru_ring_lift_inv_pow2_product(\n    uint16_t       *inv,\n    uint16_t const  dF1,\n    uint16_t const  dF2,\n    uint16_t const  dF3,\n    uint16_t const *F_buf,\n    uint16_t const  N,\n    uint16_t const  q,\n    uint16_t       *t)\n{\n    uint16_t i;\n    uint16_t j;\n    uint16_t mod_q_mask = q-1;\n    uint16_t padN;\n    ntru_ring_mult_coefficients_memreq(N, NULL, &padN);\n\n    for (j = 0; j < 4; ++j)   /* assumes 256 < q <= 65536 */\n    {\n        /* f^-1 = f^-1 * (2 - f * f^-1) mod q */\n        ntru_ring_mult_product_indices(inv, (uint16_t)dF1,\n                                       (uint16_t)dF2, (uint16_t)dF3,\n                                       F_buf, N, q,\n                                       t, t);\n        for (i = 0; i < N; ++i)\n        {\n            t[i] = -((inv[i] + 3 * t[i]) & mod_q_mask);\n        }\n        t[0] = t[0] + 2;\n        /* mult_indices works with degree N, mult_coefficients with padN */\n        memset(t+N, 0, (padN - N)*sizeof(uint16_t));\n\n        ntru_ring_mult_coefficients(inv, t, N, q, t+padN, inv);\n    }\n\n    NTRU_RET(NTRU_OK);\n}\n\n\n/* ntru_ring_lift_inv_pow2_standard\n *\n * Lifts an element of (Z/2)[x]/(x^N - 1) to (Z/q)[x]/(x^N - 1)\n * where q is a power of 2 such that 256 < q <= 65536.\n *\n * inv must be padded with zeros to the degree used by\n * ntru_ring_mult_coefficients.\n *\n * inv is assumed to be the inverse mod 2 of the trinary element f.\n * The lift is performed in place -- inv will be overwritten with the result.\n *\n * Requires scratch space for ntru_ring_mult_coefficients + one extra\n * polynomial with the same padding.\n */\nuint32_t\nntru_ring_lift_inv_pow2_standard(\n    uint16_t       *inv,\n    uint16_t const *f,\n    uint16_t const  N,\n    uint16_t const  q,\n    uint16_t       *t)\n{\n    uint16_t i;\n    uint16_t j;\n    uint16_t padN;\n    ntru_ring_mult_coefficients_memreq(N, NULL, &padN);\n\n    for (j = 0; j < 4; ++j)   /* assumes 256 < q <= 65536 */\n    {\n        /* f^-1 = f^-1 * (2 - f * f^-1) mod q */\n        ntru_ring_mult_coefficients(f, inv, N, q, t, t);\n        for (i = 0; i < N; ++i)\n        {\n            t[i] = -t[i];\n        }\n        t[0] = t[0] + 2;\n\n        ntru_ring_mult_coefficients(inv, t, N, q, t+padN, inv);\n    }\n\n    NTRU_RET(NTRU_OK);\n}\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_ntru_crypto_sha1.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File: ntru_crypto_sha1.c\n *\n * Contents: Routines implementing the SHA-1 hash calculation.\n *\n *****************************************************************************/\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_sha1.h\"\n#include \"ntru_crypto_msbyte_uint32.h\"\n\n\n/* chaining state elements */\n\n#define H0      state[0]\n#define H1      state[1]\n#define H2      state[2]\n#define H3      state[3]\n#define H4      state[4]\n\n\n/* standard SHA-1 initialization values */\n\n#define H0_INIT 0x67452301UL\n#define H1_INIT 0xefcdab89UL\n#define H2_INIT 0x98badcfeUL\n#define H3_INIT 0x10325476UL\n#define H4_INIT 0xc3d2e1f0UL\n\n\n/* sha1_blk()\n *\n * This routine updates the current hash output (chaining state)\n * by performing SHA-1 on a 512-bit block of data represented as sixteen\n * 32-bit words.\n */\n\n#define K00_19  0x5a827999UL\n#define K20_39  0x6ed9eba1UL\n#define K40_59  0x8f1bbcdcUL\n#define K60_79  0xca62c1d6UL\n\n#define RL(a, n)    ( ((a) << (n)) | ((a) >> (32 - (n))) )\n\n\nstatic void\nsha1_blk(\n    uint32_t const *data,       /*     in - ptr to 16 32-bit word input block */\n    uint32_t       *state)      /* in/out - ptr to 5 32-bit word chaining state */\n{\n    uint32_t A, B, C, D, E;\n    uint32_t w[16];\n\n    /* init A - E */\n\n    A = H0; B = H1; C = H2; D = H3; E = H4;\n\n    /* rounds 0 - 15 */\n\n    E += RL(A, 5) + K00_19 + (B & (C ^ D) ^ D) + data[ 0]; B = RL(B, 30);\n    D += RL(E, 5) + K00_19 + (A & (B ^ C) ^ C) + data[ 1]; A = RL(A, 30);\n    C += RL(D, 5) + K00_19 + (E & (A ^ B) ^ B) + data[ 2]; E = RL(E, 30);\n    B += RL(C, 5) + K00_19 + (D & (E ^ A) ^ A) + data[ 3]; D = RL(D, 30);\n    A += RL(B, 5) + K00_19 + (C & (D ^ E) ^ E) + data[ 4]; C = RL(C, 30);\n    E += RL(A, 5) + K00_19 + (B & (C ^ D) ^ D) + data[ 5]; B = RL(B, 30);\n    D += RL(E, 5) + K00_19 + (A & (B ^ C) ^ C) + data[ 6]; A = RL(A, 30);\n    C += RL(D, 5) + K00_19 + (E & (A ^ B) ^ B) + data[ 7]; E = RL(E, 30);\n    B += RL(C, 5) + K00_19 + (D & (E ^ A) ^ A) + data[ 8]; D = RL(D, 30);\n    A += RL(B, 5) + K00_19 + (C & (D ^ E) ^ E) + data[ 9]; C = RL(C, 30);\n    E += RL(A, 5) + K00_19 + (B & (C ^ D) ^ D) + data[10]; B = RL(B, 30);\n    D += RL(E, 5) + K00_19 + (A & (B ^ C) ^ C) + data[11]; A = RL(A, 30);\n    C += RL(D, 5) + K00_19 + (E & (A ^ B) ^ B) + data[12]; E = RL(E, 30);\n    B += RL(C, 5) + K00_19 + (D & (E ^ A) ^ A) + data[13]; D = RL(D, 30);\n    A += RL(B, 5) + K00_19 + (C & (D ^ E) ^ E) + data[14]; C = RL(C, 30);\n    E += RL(A, 5) + K00_19 + (B & (C ^ D) ^ D) + data[15]; B = RL(B, 30);\n\n    /* rounds 16 - 19 */\n\n    w[ 0] = data[ 0] ^ data[ 2] ^ data[ 8] ^ data[13]; w[ 0] = RL(w[0], 1);\n    D += RL(E, 5) + K00_19 + (A & (B ^ C) ^ C) + w[ 0]; A = RL(A, 30);\n    w[ 1] = data[ 1] ^ data[ 3] ^ data[ 9] ^ data[14]; w[ 1] = RL(w[1], 1);\n    C += RL(D, 5) + K00_19 + (E & (A ^ B) ^ B) + w[ 1]; E = RL(E, 30);\n    w[ 2] = data[ 2] ^ data[ 4] ^ data[10] ^ data[15]; w[ 2] = RL(w[ 2], 1);\n    B += RL(C, 5) + K00_19 + (D & (E ^ A) ^ A) + w[ 2]; D = RL(D, 30);\n    w[ 3] = data[ 3] ^ data[ 5] ^ data[11] ^ w[ 0]; w[ 3] = RL(w[ 3], 1);\n    A += RL(B, 5) + K00_19 + (C & (D ^ E) ^ E) + w[ 3]; C = RL(C, 30);\n\n    /* rounds 20 - 39 */\n\n    w[ 4] = data[ 4] ^ data[ 6] ^ data[12] ^ w[ 1]; w[ 4] = RL(w[ 4], 1);\n    E += RL(A, 5) + K20_39 + (B ^ C ^ D) + w[ 4]; B = RL(B, 30);\n    w[ 5] = data[ 5] ^ data[ 7] ^ data[13] ^ w[ 2]; w[ 5] = RL(w[ 5], 1);\n    D += RL(E, 5) + K20_39 + (A ^ B ^ C) + w[ 5]; A = RL(A, 30);\n    w[ 6] = data[ 6] ^ data[ 8] ^ data[14] ^ w[ 3]; w[ 6] = RL(w[ 6], 1);\n    C += RL(D, 5) + K20_39 + (E ^ A ^ B) + w[ 6]; E = RL(E, 30);\n    w[ 7] = data[ 7] ^ data[ 9] ^ data[15] ^ w[ 4]; w[ 7] = RL(w[ 7], 1);\n    B += RL(C, 5) + K20_39 + (D ^ E ^ A) + w[ 7]; D = RL(D, 30);\n    w[ 8] = data[ 8] ^ data[10] ^ w[ 0] ^ w[ 5]; w[ 8] = RL(w[ 8], 1);\n    A += RL(B, 5) + K20_39 + (C ^ D ^ E) + w[ 8]; C = RL(C, 30);\n    w[ 9] = data[ 9] ^ data[11] ^ w[ 1] ^ w[ 6]; w[ 9] = RL(w[ 9], 1);\n    E += RL(A, 5) + K20_39 + (B ^ C ^ D) + w[ 9]; B = RL(B, 30);\n    w[10] = data[10] ^ data[12] ^ w[ 2] ^ w[ 7]; w[10] = RL(w[10], 1);\n    D += RL(E, 5) + K20_39 + (A ^ B ^ C) + w[10]; A = RL(A, 30);\n    w[11] = data[11] ^ data[13] ^ w[ 3] ^ w[ 8]; w[11] = RL(w[11], 1);\n    C += RL(D, 5) + K20_39 + (E ^ A ^ B) + w[11]; E = RL(E, 30);\n    w[12] = data[12] ^ data[14] ^ w[ 4] ^ w[ 9]; w[12] = RL(w[12], 1);\n    B += RL(C, 5) + K20_39 + (D ^ E ^ A) + w[12]; D = RL(D, 30);\n    w[13] = data[13] ^ data[15] ^ w[ 5] ^ w[10]; w[13] = RL(w[13], 1);\n    A += RL(B, 5) + K20_39 + (C ^ D ^ E) + w[13]; C = RL(C, 30);\n    w[14] = data[14] ^ w[ 0] ^ w[ 6] ^ w[11]; w[14] = RL(w[14], 1);\n    E += RL(A, 5) + K20_39 + (B ^ C ^ D) + w[14]; B = RL(B, 30);\n    w[15] = data[15] ^ w[ 1] ^ w[ 7] ^ w[12]; w[15] = RL(w[15], 1);\n    D += RL(E, 5) + K20_39 + (A ^ B ^ C) + w[15]; A = RL(A, 30);\n    w[ 0] = w[ 0] ^ w[ 2] ^ w[ 8] ^ w[13]; w[ 0] = RL(w[ 0], 1);\n    C += RL(D, 5) + K20_39 + (E ^ A ^ B) + w[ 0]; E = RL(E, 30);\n    w[ 1] = w[ 1] ^ w[ 3] ^ w[ 9] ^ w[14]; w[ 1] = RL(w[ 1], 1);\n    B += RL(C, 5) + K20_39 + (D ^ E ^ A) + w[ 1]; D = RL(D, 30);\n    w[ 2] = w[ 2] ^ w[ 4] ^ w[10] ^ w[15]; w[ 2] = RL(w[ 2], 1);\n    A += RL(B, 5) + K20_39 + (C ^ D ^ E) + w[ 2]; C = RL(C, 30);\n    w[ 3] = w[ 3] ^ w[ 5] ^ w[11] ^ w[ 0]; w[ 3] = RL(w[ 3], 1);\n    E += RL(A, 5) + K20_39 + (B ^ C ^ D) + w[ 3]; B = RL(B, 30);\n    w[ 4] = w[ 4] ^ w[ 6] ^ w[12] ^ w[ 1]; w[ 4] = RL(w[ 4], 1);\n    D += RL(E, 5) + K20_39 + (A ^ B ^ C) + w[ 4]; A = RL(A, 30);\n    w[ 5] = w[ 5] ^ w[ 7] ^ w[13] ^ w[ 2]; w[ 5] = RL(w[ 5], 1);\n    C += RL(D, 5) + K20_39 + (E ^ A ^ B) + w[ 5]; E = RL(E, 30);\n    w[ 6] = w[ 6] ^ w[ 8] ^ w[14] ^ w[ 3]; w[ 6] = RL(w[ 6], 1);\n    B += RL(C, 5) + K20_39 + (D ^ E ^ A) + w[ 6]; D = RL(D, 30);\n    w[ 7] = w[ 7] ^ w[ 9] ^ w[15] ^ w[ 4]; w[ 7] = RL(w[ 7], 1);\n    A += RL(B, 5) + K20_39 + (C ^ D ^ E) + w[ 7]; C = RL(C, 30);\n\n    /* rounds 40 - 59 */\n\n    w[ 8] = w[ 8] ^ w[10] ^ w[ 0] ^ w[ 5]; w[ 8] = RL(w[ 8], 1);\n    E += RL(A, 5) + K40_59 + ((B & C) | (D & (B | C))) + w[ 8]; B = RL(B, 30);\n    w[ 9] = w[ 9] ^ w[11] ^ w[ 1] ^ w[ 6]; w[ 9] = RL(w[ 9], 1);\n    D += RL(E, 5) + K40_59 + ((A & B) | (C & (A | B))) + w[ 9]; A = RL(A, 30);\n    w[10] = w[10] ^ w[12] ^ w[ 2] ^ w[ 7]; w[10] = RL(w[10], 1);\n    C += RL(D, 5) + K40_59 + ((E & A) | (B & (E | A))) + w[10]; E = RL(E, 30);\n    w[11] = w[11] ^ w[13] ^ w[ 3] ^ w[ 8]; w[11] = RL(w[11], 1);\n    B += RL(C, 5) + K40_59 + ((D & E) | (A & (D | E))) + w[11]; D = RL(D, 30);\n    w[12] = w[12] ^ w[14] ^ w[ 4] ^ w[ 9]; w[12] = RL(w[12], 1);\n    A += RL(B, 5) + K40_59 + ((C & D) | (E & (C | D))) + w[12]; C = RL(C, 30);\n    w[13] = w[13] ^ w[15] ^ w[ 5] ^ w[10]; w[13] = RL(w[13], 1);\n    E += RL(A, 5) + K40_59 + ((B & C) | (D & (B | C))) + w[13]; B = RL(B, 30);\n    w[14] = w[14] ^ w[ 0] ^ w[ 6] ^ w[11]; w[14] = RL(w[14], 1);\n    D += RL(E, 5) + K40_59 + ((A & B) | (C & (A | B))) + w[14]; A = RL(A, 30);\n    w[15] = w[15] ^ w[ 1] ^ w[ 7] ^ w[12]; w[15] = RL(w[15], 1);\n    C += RL(D, 5) + K40_59 + ((E & A) | (B & (E | A))) + w[15]; E = RL(E, 30);\n    w[ 0] = w[ 0] ^ w[ 2] ^ w[ 8] ^ w[13]; w[ 0] = RL(w[ 0], 1);\n    B += RL(C, 5) + K40_59 + ((D & E) | (A & (D | E))) + w[ 0]; D = RL(D, 30);\n    w[ 1] = w[ 1] ^ w[ 3] ^ w[ 9] ^ w[14]; w[ 1] = RL(w[ 1], 1);\n    A += RL(B, 5) + K40_59 + ((C & D) | (E & (C | D))) + w[ 1]; C = RL(C, 30);\n    w[ 2] = w[ 2] ^ w[ 4] ^ w[10] ^ w[15]; w[ 2] = RL(w[ 2], 1);\n    E += RL(A, 5) + K40_59 + ((B & C) | (D & (B | C))) + w[ 2]; B = RL(B, 30);\n    w[ 3] = w[ 3] ^ w[ 5] ^ w[11] ^ w[ 0]; w[ 3] = RL(w[ 3], 1);\n    D += RL(E, 5) + K40_59 + ((A & B) | (C & (A | B))) + w[ 3]; A = RL(A, 30);\n    w[ 4] = w[ 4] ^ w[ 6] ^ w[12] ^ w[ 1]; w[ 4] = RL(w[ 4], 1);\n    C += RL(D, 5) + K40_59 + ((E & A) | (B & (E | A))) + w[ 4]; E = RL(E, 30);\n    w[ 5] = w[ 5] ^ w[ 7] ^ w[13] ^ w[ 2]; w[ 5] = RL(w[ 5], 1);\n    B += RL(C, 5) + K40_59 + ((D & E) | (A & (D | E))) + w[ 5]; D = RL(D, 30);\n    w[ 6] = w[ 6] ^ w[ 8] ^ w[14] ^ w[ 3]; w[ 6] = RL(w[ 6], 1);\n    A += RL(B, 5) + K40_59 + ((C & D) | (E & (C | D))) + w[ 6]; C = RL(C, 30);\n    w[ 7] = w[ 7] ^ w[ 9] ^ w[15] ^ w[ 4]; w[ 7] = RL(w[ 7], 1);\n    E += RL(A, 5) + K40_59 + ((B & C) | (D & (B | C))) + w[ 7]; B = RL(B, 30);\n    w[ 8] = w[ 8] ^ w[10] ^ w[ 0] ^ w[ 5]; w[ 8] = RL(w[ 8], 1);\n    D += RL(E, 5) + K40_59 + ((A & B) | (C & (A | B))) + w[ 8]; A = RL(A, 30);\n    w[ 9] = w[ 9] ^ w[11] ^ w[ 1] ^ w[ 6]; w[ 9] = RL(w[ 9], 1);\n    C += RL(D, 5) + K40_59 + ((E & A) | (B & (E | A))) + w[ 9]; E = RL(E, 30);\n    w[10] = w[10] ^ w[12] ^ w[ 2] ^ w[ 7]; w[10] = RL(w[10], 1);\n    B += RL(C, 5) + K40_59 + ((D & E) | (A & (D | E))) + w[10]; D = RL(D, 30);\n    w[11] = w[11] ^ w[13] ^ w[ 3] ^ w[ 8]; w[11] = RL(w[11], 1);\n    A += RL(B, 5) + K40_59 + ((C & D) | (E & (C | D))) + w[11]; C = RL(C, 30);\n\n    /* rounds 60 - 79 */\n\n    w[12] = w[12] ^ w[14] ^ w[ 4] ^ w[ 9]; w[12] = RL(w[12], 1);\n    E += RL(A, 5) + K60_79 + (B ^ C ^ D) + w[12]; B = RL(B, 30);\n    w[13] = w[13] ^ w[15] ^ w[ 5] ^ w[10]; w[13] = RL(w[13], 1);\n    D += RL(E, 5) + K60_79 + (A ^ B ^ C) + w[13]; A = RL(A, 30);\n    w[14] = w[14] ^ w[ 0] ^ w[ 6] ^ w[11]; w[14] = RL(w[14], 1);\n    C += RL(D, 5) + K60_79 + (E ^ A ^ B) + w[14]; E = RL(E, 30);\n    w[15] = w[15] ^ w[ 1] ^ w[ 7] ^ w[12]; w[15] = RL(w[15], 1);\n    B += RL(C, 5) + K60_79 + (D ^ E ^ A) + w[15]; D = RL(D, 30);\n    w[ 0] = w[ 0] ^ w[ 2] ^ w[ 8] ^ w[13]; w[ 0] = RL(w[ 0], 1);\n    A += RL(B, 5) + K60_79 + (C ^ D ^ E) + w[ 0]; C = RL(C, 30);\n    w[ 1] = w[ 1] ^ w[ 3] ^ w[ 9] ^ w[14]; w[ 1] = RL(w[ 1], 1);\n    E += RL(A, 5) + K60_79 + (B ^ C ^ D) + w[ 1]; B = RL(B, 30);\n    w[ 2] = w[ 2] ^ w[ 4] ^ w[10] ^ w[15]; w[ 2] = RL(w[ 2], 1);\n    D += RL(E, 5) + K60_79 + (A ^ B ^ C) + w[ 2]; A = RL(A, 30);\n    w[ 3] = w[ 3] ^ w[ 5] ^ w[11] ^ w[ 0]; w[ 3] = RL(w[ 3], 1);\n    C += RL(D, 5) + K60_79 + (E ^ A ^ B) + w[ 3]; E = RL(E, 30);\n    w[ 4] = w[ 4] ^ w[ 6] ^ w[12] ^ w[ 1]; w[ 4] = RL(w[ 4], 1);\n    B += RL(C, 5) + K60_79 + (D ^ E ^ A) + w[ 4]; D = RL(D, 30);\n    w[ 5] = w[ 5] ^ w[ 7] ^ w[13] ^ w[ 2]; w[ 5] = RL(w[ 5], 1);\n    A += RL(B, 5) + K60_79 + (C ^ D ^ E) + w[ 5]; C = RL(C, 30);\n    w[ 6] = w[ 6] ^ w[ 8] ^ w[14] ^ w[ 3]; w[ 6] = RL(w[ 6], 1);\n    E += RL(A, 5) + K60_79 + (B ^ C ^ D) + w[ 6]; B = RL(B, 30);\n    w[ 7] = w[ 7] ^ w[ 9] ^ w[15] ^ w[ 4]; w[ 7] = RL(w[ 7], 1);\n    D += RL(E, 5) + K60_79 + (A ^ B ^ C) + w[ 7]; A = RL(A, 30);\n    w[ 8] = w[ 8] ^ w[10] ^ w[ 0] ^ w[ 5]; w[ 8] = RL(w[ 8], 1);\n    C += RL(D, 5) + K60_79 + (E ^ A ^ B) + w[ 8]; E = RL(E, 30);\n    w[ 9] = w[ 9] ^ w[11] ^ w[ 1] ^ w[ 6]; w[ 9] = RL(w[ 9], 1);\n    B += RL(C, 5) + K60_79 + (D ^ E ^ A) + w[ 9]; D = RL(D, 30);\n    w[10] = w[10] ^ w[12] ^ w[ 2] ^ w[ 7]; w[10] = RL(w[10], 1);\n    A += RL(B, 5) + K60_79 + (C ^ D ^ E) + w[10]; C = RL(C, 30);\n    w[11] = w[11] ^ w[13] ^ w[ 3] ^ w[ 8]; w[11] = RL(w[11], 1);\n    E += RL(A, 5) + K60_79 + (B ^ C ^ D) + w[11]; B = RL(B, 30);\n    w[12] = w[12] ^ w[14] ^ w[ 4] ^ w[ 9]; w[12] = RL(w[12], 1);\n    D += RL(E, 5) + K60_79 + (A ^ B ^ C) + w[12]; A = RL(A, 30);\n    w[13] = w[13] ^ w[15] ^ w[ 5] ^ w[10];\n    C += RL(D, 5) + K60_79 + (E ^ A ^ B) + RL(w[13], 1); E = RL(E, 30);\n    w[14] = w[14] ^ w[ 0] ^ w[ 6] ^ w[11];\n    B += RL(C, 5) + K60_79 + (D ^ E ^ A) + RL(w[14], 1); D = RL(D, 30);\n\n    /* update H0 - H4 */\n\n    w[15] = w[15] ^ w[ 1] ^ w[ 7] ^ w[12];\n    H0 += A + RL(B, 5) + K60_79 + (C ^ D ^ E) + RL(w[15], 1);\n    H1 += B;\n    H2 += RL(C, 30);\n    H3 += D;\n    H4 += E;\n\n    /* clear temp variables */\n\n    A = B = C = D = E = 0;\n    memset(w, 0, sizeof(w));\n}\n\n\n/* ntru_crypto_sha1()\n *\n * This routine provides all operations for a SHA-1 hash, and the use\n * of SHA-1 for DSA signing and key generation.\n * It may be used to initialize, update, or complete a message digest,\n * or any combination of those actions, as determined by the SHA_INIT flag,\n * the in_len parameter, and the SHA_FINISH flag, respectively.\n *\n * When in_len == 0 (no data to hash), the parameter, in, may be NULL.\n * When the SHA_FINISH flag is not set, the parameter, md, may be NULL.\n *\n * Initialization may be standard or use a specified initialization vector,\n * and is indicated by setting the SHA_INIT flag.\n * Setting init = NULL specifies standard initialization.  Otherwise, init\n * points to the array of five alternate initialization 32-bit words.\n *\n * The hash operation can be updated with any number of input bytes, including\n * zero.\n *\n * Returns SHA_OK on success.\n * Returns SHA_FAIL with corrupted context.\n * Returns SHA_BAD_PARAMETER if  inappropriate NULL pointers are passed.\n * Returns SHA_OVERFLOW if more than 2^64 - 1 bytes are hashed.\n */\n\nuint32_t\nntru_crypto_sha1(\n    NTRU_CRYPTO_SHA1_CTX *c,        /* in/out - pointer to SHA-1 context */\n    uint32_t const       *init,     /*     in - pointer to alternate */\n                                    /*          initialization - may be NULL */\n    uint8_t const        *in,       /*     in - pointer to input data -\n                                                may be NULL if in_len == 0 */\n    uint32_t              in_len,   /*     in - number of input data bytes */\n    uint32_t              flags,    /*     in - INIT, FINISH flags */\n    uint8_t              *md)       /*    out - address for message digest -\n                                                may be NULL if not FINISH */\n{\n    uint32_t    in_blk[16];         /* input block */\n    uint32_t    space;\n    uint8_t    *d = NULL;\n\n    /* check error conditions */\n\n    if (!c || (in_len && !in) || ((flags & SHA_FINISH) && !md))\n    {\n        SHA_RET(SHA_BAD_PARAMETER)\n    }\n\n    /* initialize context if requested */\n\n    if (flags & SHA_INIT)\n    {\n\n        /* init chaining state */\n\n        if (!init)\n        {\n            c->state[0] = H0_INIT;              /* standard initialization */\n            c->state[1] = H1_INIT;\n            c->state[2] = H2_INIT;\n            c->state[3] = H3_INIT;\n            c->state[4] = H4_INIT;\n        }\n        else\n        {\n            /* Non standard initialization values are not supported */\n            SHA_RET(SHA_BAD_PARAMETER);\n        }\n\n        /* init bit count and number of unhashed data bytes */\n\n        c->num_bits_hashed[0] = 0;\n        c->num_bits_hashed[1] = 0;\n        c->unhashed_len = 0;\n    }\n\n    /* determine space left in unhashed data buffer */\n\n    if (c->unhashed_len > 63)\n    {\n        SHA_RET(SHA_FAIL)\n    }\n    \n    space = 64 - c->unhashed_len;\n\n    /* process input if it exists */\n\n    if (in_len)\n    {\n\n        /* update count of bits hashed */\n\n        {\n            uint32_t    bits0, bits1;\n\n            bits0 = in_len << 3;\n            bits1 = in_len >> 29;\n            \n            if ((c->num_bits_hashed[0] += bits0) < bits0)\n            {\n                bits1++;\n            }\n            \n            if ((c->num_bits_hashed[1] += bits1) < bits1)\n            {\n                memset((uint8_t *) c, 0, sizeof(NTRU_CRYPTO_SHA1_CTX));\n                memset((char *) in_blk, 0, sizeof(in_blk));\n                SHA_RET(SHA_OVERFLOW)\n            }\n        }\n\n        /* process input bytes */\n\n        if (in_len < space)\n        {\n\n            /* input does not fill block buffer:\n             * add input to buffer\n             */\n\n            memcpy(c->unhashed + c->unhashed_len, in, in_len);\n            c->unhashed_len += in_len;\n\n        }\n        else\n        {\n            uint32_t    blks;\n\n            /* input will fill block buffer:\n             *  fill unhashed data buffer,\n             *  convert to block buffer,\n             *  and process block\n             */\n\n            in_len -= space;\n            \n            for (d = c->unhashed + c->unhashed_len; space; space--)\n            {\n                *d++ = *in++;\n            }\n            \n            ntru_crypto_msbyte_2_uint32(in_blk, (uint8_t const *) c->unhashed,\n                                        16);\n            sha1_blk((uint32_t const *) in_blk, c->state);\n\n            /* process any remaining full blocks */\n\n            for (blks = in_len >> 6; blks--; in += 64)\n            {\n                ntru_crypto_msbyte_2_uint32(in_blk, in, 16);\n                sha1_blk((uint32_t const *) in_blk, c->state);\n            }\n\n            /* put any remaining input in the unhashed data buffer */\n\n            in_len &= 0x3f;\n            memcpy(c->unhashed, in, in_len);\n            c->unhashed_len = in_len;\n        }\n    }\n\n    /* complete message digest if requested */\n\n    if (flags & SHA_FINISH)\n    {\n        space = 64 - c->unhashed_len;\n\n        /* add 0x80 padding byte to the unhashed data buffer\n         * (there is always space since the buffer can't be full)\n         */\n\n        d = c->unhashed + c->unhashed_len;\n        *d++ = 0x80;\n        space--;\n\n        /* check for space for bit count */\n\n        if (space < 8)\n        {\n\n            /* no space for count:\n             *  fill remainder of unhashed data buffer with zeros,\n             *  convert to input block,\n             *  process block,\n             *  fill all but 8 bytes of unhashed data buffer with zeros\n             */\n\n            memset(d, 0, space);\n            ntru_crypto_msbyte_2_uint32(in_blk,\n                                        (uint8_t const *) c->unhashed, 16);\n            sha1_blk((uint32_t const *) in_blk, c->state);\n            memset(c->unhashed, 0, 56);\n\n        }\n        else\n        {\n\n            /* fill unhashed data buffer with zeros,\n             *  leaving space for bit count\n             */\n\n            for (space -= 8; space; space--)\n            {\n                *d++ = 0;\n            }\n        }\n\n        /* convert partially filled unhashed data buffer to input block and\n         *  add bit count to input block\n         */\n\n        ntru_crypto_msbyte_2_uint32(in_blk, (uint8_t const *) c->unhashed,\n                                    14);\n        in_blk[14] = c->num_bits_hashed[1];\n        in_blk[15] = c->num_bits_hashed[0];\n\n        /* process last block */\n\n        sha1_blk((uint32_t const *) in_blk, c->state);\n\n        /* copy result to message digest buffer */\n\n        ntru_crypto_uint32_2_msbyte(md, c->state, 5);\n        \n        /* clear context and stack variables */\n\n        memset((uint8_t *) c, 0, sizeof(NTRU_CRYPTO_SHA1_CTX));\n        memset((char *) in_blk, 0, sizeof(in_blk));\n    }\n\n    SHA_RET(SHA_OK)\n}\n\n\n/* ntru_crypto_sha1_init\n *\n * This routine performs standard initialization of the SHA-1 state.\n *\n * Returns SHA_OK on success.\n * Returns SHA_FAIL with corrupted context.\n * Returns SHA_BAD_PARAMETER if inappropriate NULL pointers are passed.\n */\n\nuint32_t\nntru_crypto_sha1_init(\n    NTRU_CRYPTO_SHA1_CTX *c)        /* in/out - pointer to SHA-1 context */\n{\n    return ntru_crypto_sha1(c, NULL, NULL, 0, SHA_INIT, NULL);\n}\n\n\n/* ntru_crypto_sha1_update\n *\n * This routine processes input data and updates the SHA-1 hash calculation.\n *\n * Returns SHA_OK on success.\n * Returns SHA_FAIL with corrupted context.\n * Returns SHA_BAD_PARAMETER if inappropriate NULL pointers are passed.\n * Returns SHA_OVERFLOW if more than 2^64 - 1 bytes are hashed.\n */\n\nuint32_t\nntru_crypto_sha1_update(\n    NTRU_CRYPTO_SHA1_CTX *c,        /* in/out - pointer to SHA-1 context */\n    uint8_t const        *data,     /*    in - pointer to input data */\n    uint32_t              data_len) /*    in - number of bytes of input data */\n{\n    return ntru_crypto_sha1(c, NULL, data, data_len, SHA_DATA_ONLY, NULL);\n}\n\n\n/* ntru_crypto_sha1_final\n *\n * This routine completes the SHA-1 hash calculation and returns the\n * message digest.\n *\n * Returns SHA_OK on success.\n * Returns SHA_FAIL with corrupted context.\n * Returns SHA_BAD_PARAMETER if inappropriate NULL pointers are passed.\n * Returns SHA_OVERFLOW if more than 2^64 - 1 bytes are hashed.\n */\n\nuint32_t\nntru_crypto_sha1_final(\n    NTRU_CRYPTO_SHA1_CTX *c,        /* in/out - pointer to SHA-1 context */\n    uint8_t              *md)       /*   out - address for message digest */\n{\n    return ntru_crypto_sha1(c, NULL, NULL, 0, SHA_FINISH, md);\n}\n\n/* ntru_crypto_sha1_digest\n *\n * This routine computes a SHA-1 message digest.\n *\n * Returns SHA_OK on success.\n * Returns SHA_FAIL with corrupted context.\n * Returns SHA_BAD_PARAMETER if inappropriate NULL pointers are passed.\n * Returns SHA_OVERFLOW if more than 2^64 - 1 bytes are hashed.\n */\n\nuint32_t\nntru_crypto_sha1_digest(\n    uint8_t const  *data,           /*  in - pointer to input data */\n    uint32_t        data_len,       /*  in - number of bytes of input data */\n    uint8_t        *md)             /* out - address for message digest */\n{\n    NTRU_CRYPTO_SHA1_CTX c;\n\n    return ntru_crypto_sha1(&c, NULL, data, data_len, SHA_INIT | SHA_FINISH, md);\n}\n\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_sha2.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File: ntru_crypto_sha2.c\n *\n * Contents: Routines implementing the SHA-256 hash calculation.\n *\n *****************************************************************************/\n\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_sha2.h\"\n#include \"ntru_crypto_msbyte_uint32.h\"\n\n\n/* chaining state elements */\n\n#define H0      state[0]\n#define H1      state[1]\n#define H2      state[2]\n#define H3      state[3]\n#define H4      state[4]\n#define H5      state[5]\n#define H6      state[6]\n#define H7      state[7]\n\n\n/* standard SHA-256 initialization values */\n\n#define H0_SHA256_INIT 0x6a09e667UL\n#define H1_SHA256_INIT 0xbb67ae85UL\n#define H2_SHA256_INIT 0x3c6ef372UL\n#define H3_SHA256_INIT 0xa54ff53aUL\n#define H4_SHA256_INIT 0x510e527fUL\n#define H5_SHA256_INIT 0x9b05688cUL\n#define H6_SHA256_INIT 0x1f83d9abUL\n#define H7_SHA256_INIT 0x5be0cd19UL\n\n\n/* sha2_blk()\n *\n * This routine updates the current hash output (chaining state)\n * by performing SHA-256 on a 512-bit block of data represented\n * as sixteen 32-bit words.\n */\n\n#define RR(a, n)    ( ((a) >> (n)) | ((a) << (32 - (n))) )\n#define S0(a)       ( RR((a),  2) ^ RR((a), 13) ^ RR((a), 22) )\n#define S1(a)       ( RR((a),  6) ^ RR((a), 11) ^ RR((a), 25) )\n#define s0(a)       ( RR((a),  7) ^ RR((a), 18) ^ ((a) >>  3) )\n#define s1(a)       ( RR((a), 17) ^ RR((a), 19) ^ ((a) >> 10) )\n\n\nstatic void\nsha2_blk(\n    uint32_t const *data,     /*     in - ptr to 16 32-bit word input block */\n    uint32_t       *state)    /* in/out - ptr to 8 32-bit word chaining state */\n{\n    uint32_t A, B, C, D, E, F, G, H;\n    uint32_t w[16];\n\n    /* init A - H */\n\n    A = H0; B = H1; C = H2; D = H3; E = H4; F = H5; G = H6; H = H7;\n\n    /* rounds 0 - 15 */\n\n    H += S1(E) + (E & (F ^ G) ^ G) + 0x428A2F98UL + data[ 0]; D += H;\n    H += S0(A) + ((A & B) | (C & (A | B)));\n    G += S1(D) + (D & (E ^ F) ^ F) + 0x71374491UL + data[ 1]; C += G;\n    G += S0(H) + ((H & A) | (B & (H | A)));\n    F += S1(C) + (C & (D ^ E) ^ E) + 0xB5C0FBCFUL + data[ 2]; B += F;\n    F += S0(G) + ((G & H) | (A & (G | H)));\n    E += S1(B) + (B & (C ^ D) ^ D) + 0xE9B5DBA5UL + data[ 3]; A += E;\n    E += S0(F) + ((F & G) | (H & (F | G)));\n    D += S1(A) + (A & (B ^ C) ^ C) + 0x3956C25BUL + data[ 4]; H += D;\n    D += S0(E) + ((E & F) | (G & (E | F)));\n    C += S1(H) + (H & (A ^ B) ^ B) + 0x59F111F1UL + data[ 5]; G += C;\n    C += S0(D) + ((D & E) | (F & (D | E)));\n    B += S1(G) + (G & (H ^ A) ^ A) + 0x923F82A4UL + data[ 6]; F += B;\n    B += S0(C) + ((C & D) | (E & (C | D)));\n    A += S1(F) + (F & (G ^ H) ^ H) + 0xAB1C5ED5UL + data[ 7]; E += A;\n    A += S0(B) + ((B & C) | (D & (B | C)));\n    H += S1(E) + (E & (F ^ G) ^ G) + 0xD807AA98UL + data[ 8]; D += H;\n    H += S0(A) + ((A & B) | (C & (A | B)));\n    G += S1(D) + (D & (E ^ F) ^ F) + 0x12835B01UL + data[ 9]; C += G;\n    G += S0(H) + ((H & A) | (B & (H | A)));\n    F += S1(C) + (C & (D ^ E) ^ E) + 0x243185BEUL + data[10]; B += F;\n    F += S0(G) + ((G & H) | (A & (G | H)));\n    E += S1(B) + (B & (C ^ D) ^ D) + 0x550C7DC3UL + data[11]; A += E;\n    E += S0(F) + ((F & G) | (H & (F | G)));\n    D += S1(A) + (A & (B ^ C) ^ C) + 0x72BE5D74UL + data[12]; H += D;\n    D += S0(E) + ((E & F) | (G & (E | F)));\n    C += S1(H) + (H & (A ^ B) ^ B) + 0x80DEB1FEUL + data[13]; G += C;\n    C += S0(D) + ((D & E) | (F & (D | E)));\n    B += S1(G) + (G & (H ^ A) ^ A) + 0x9BDC06A7UL + data[14]; F += B;\n    B += S0(C) + ((C & D) | (E & (C | D)));\n    A += S1(F) + (F & (G ^ H) ^ H) + 0xC19BF174UL + data[15]; E += A;\n    A += S0(B) + ((B & C) | (D & (B | C)));\n\n    /* rounds 16 - 63 */\n\n    w[ 0] = data[ 0] + s0(data[ 1]) + data[ 9] + s1(data[14]);\n    H += S1(E) + (E & (F ^ G) ^ G) + 0xE49B69C1UL + w[ 0]; D += H;\n    H += S0(A) + ((A & B) | (C & (A | B)));\n    w[ 1] = data[ 1] + s0(data[ 2]) + data[10] + s1(data[15]);\n    G += S1(D) + (D & (E ^ F) ^ F) + 0xEFBE4786UL + w[ 1]; C += G;\n    G += S0(H) + ((H & A) | (B & (H | A)));\n    w[ 2] = data[ 2] + s0(data[ 3]) + data[11] + s1(w[ 0]);\n    F += S1(C) + (C & (D ^ E) ^ E) + 0x0FC19DC6UL + w[ 2]; B += F;\n    F += S0(G) + ((G & H) | (A & (G | H)));\n    w[ 3] = data[ 3] + s0(data[ 4]) + data[12] + s1(w[ 1]);\n    E += S1(B) + (B & (C ^ D) ^ D) + 0x240CA1CCUL + w[ 3]; A += E;\n    E += S0(F) + ((F & G) | (H & (F | G)));\n    w[ 4] = data[ 4] + s0(data[ 5]) + data[13] + s1(w[ 2]);\n    D += S1(A) + (A & (B ^ C) ^ C) + 0x2DE92C6FUL + w[ 4]; H += D;\n    D += S0(E) + ((E & F) | (G & (E | F)));\n    w[ 5] = data[ 5] + s0(data[ 6]) + data[14] + s1(w[ 3]);\n    C += S1(H) + (H & (A ^ B) ^ B) + 0x4A7484AAUL + w[ 5]; G += C;\n    C += S0(D) + ((D & E) | (F & (D | E)));\n    w[ 6] = data[ 6] + s0(data[ 7]) + data[15] + s1(w[ 4]);\n    B += S1(G) + (G & (H ^ A) ^ A) + 0x5CB0A9DCUL + w[ 6]; F += B;\n    B += S0(C) + ((C & D) | (E & (C | D)));\n    w[ 7] = data[ 7] + s0(data[ 8]) + w[ 0] + s1(w[ 5]);\n    A += S1(F) + (F & (G ^ H) ^ H) + 0x76F988DAUL + w[ 7]; E += A;\n    A += S0(B) + ((B & C) | (D & (B | C)));\n    w[ 8] = data[ 8] + s0(data[ 9]) + w[ 1] + s1(w[ 6]);\n    H += S1(E) + (E & (F ^ G) ^ G) + 0x983E5152UL + w[ 8]; D += H;\n    H += S0(A) + ((A & B) | (C & (A | B)));\n    w[ 9] = data[ 9] + s0(data[10]) + w[ 2] + s1(w[ 7]);\n    G += S1(D) + (D & (E ^ F) ^ F) + 0xA831C66DUL + w[ 9]; C += G;\n    G += S0(H) + ((H & A) | (B & (H | A)));\n    w[10] = data[10] + s0(data[11]) + w[ 3] + s1(w[ 8]);\n    F += S1(C) + (C & (D ^ E) ^ E) + 0xB00327C8UL + w[10]; B += F;\n    F += S0(G) + ((G & H) | (A & (G | H)));\n    w[11] = data[11] + s0(data[12]) + w[ 4] + s1(w[ 9]);\n    E += S1(B) + (B & (C ^ D) ^ D) + 0xBF597FC7UL + w[11]; A += E;\n    E += S0(F) + ((F & G) | (H & (F | G)));\n    w[12] = data[12] + s0(data[13]) + w[ 5] + s1(w[10]);\n    D += S1(A) + (A & (B ^ C) ^ C) + 0xC6E00BF3UL + w[12]; H += D;\n    D += S0(E) + ((E & F) | (G & (E | F)));\n    w[13] = data[13] + s0(data[14]) + w[ 6] + s1(w[11]);\n    C += S1(H) + (H & (A ^ B) ^ B) + 0xD5A79147UL + w[13]; G += C;\n    C += S0(D) + ((D & E) | (F & (D | E)));\n    w[14] = data[14] + s0(data[15]) + w[ 7] + s1(w[12]);\n    B += S1(G) + (G & (H ^ A) ^ A) + 0x06CA6351UL + w[14]; F += B;\n    B += S0(C) + ((C & D) | (E & (C | D)));\n    w[15] = data[15] + s0(w[ 0]) + w[ 8] + s1(w[13]);\n    A += S1(F) + (F & (G ^ H) ^ H) + 0x14292967UL + w[15]; E += A;\n    A += S0(B) + ((B & C) | (D & (B | C)));\n    w[ 0] = w[ 0] + s0(w[ 1]) + w[ 9] + s1(w[14]);\n    H += S1(E) + (E & (F ^ G) ^ G) + 0x27B70A85UL + w[ 0]; D += H;\n    H += S0(A) + ((A & B) | (C & (A | B)));\n    w[ 1] = w[ 1] + s0(w[ 2]) + w[10] + s1(w[15]);\n    G += S1(D) + (D & (E ^ F) ^ F) + 0x2E1B2138UL + w[ 1]; C += G;\n    G += S0(H) + ((H & A) | (B & (H | A)));\n    w[ 2] = w[ 2] + s0(w[ 3]) + w[11] + s1(w[ 0]);\n    F += S1(C) + (C & (D ^ E) ^ E) + 0x4D2C6DFCUL + w[ 2]; B += F;\n    F += S0(G) + ((G & H) | (A & (G | H)));\n    w[ 3] = w[ 3] + s0(w[ 4]) + w[12] + s1(w[ 1]);\n    E += S1(B) + (B & (C ^ D) ^ D) + 0x53380D13UL + w[ 3]; A += E;\n    E += S0(F) + ((F & G) | (H & (F | G)));\n    w[ 4] = w[ 4] + s0(w[ 5]) + w[13] + s1(w[ 2]);\n    D += S1(A) + (A & (B ^ C) ^ C) + 0x650A7354UL + w[ 4]; H += D;\n    D += S0(E) + ((E & F) | (G & (E | F)));\n    w[ 5] = w[ 5] + s0(w[ 6]) + w[14] + s1(w[ 3]);\n    C += S1(H) + (H & (A ^ B) ^ B) + 0x766A0ABBUL + w[ 5]; G += C;\n    C += S0(D) + ((D & E) | (F & (D | E)));\n    w[ 6] = w[ 6] + s0(w[ 7]) + w[15] + s1(w[ 4]);\n    B += S1(G) + (G & (H ^ A) ^ A) + 0x81C2C92EUL + w[ 6]; F += B;\n    B += S0(C) + ((C & D) | (E & (C | D)));\n    w[ 7] = w[ 7] + s0(w[ 8]) + w[ 0] + s1(w[ 5]);\n    A += S1(F) + (F & (G ^ H) ^ H) + 0x92722C85UL + w[ 7]; E += A;\n    A += S0(B) + ((B & C) | (D & (B | C)));\n    w[ 8] = w[ 8] + s0(w[ 9]) + w[ 1] + s1(w[ 6]);\n    H += S1(E) + (E & (F ^ G) ^ G) + 0xA2BFE8A1UL + w[ 8]; D += H;\n    H += S0(A) + ((A & B) | (C & (A | B)));\n    w[ 9] = w[ 9] + s0(w[10]) + w[ 2] + s1(w[ 7]);\n    G += S1(D) + (D & (E ^ F) ^ F) + 0xA81A664BUL + w[ 9]; C += G;\n    G += S0(H) + ((H & A) | (B & (H | A)));\n    w[10] = w[10] + s0(w[11]) + w[ 3] + s1(w[ 8]);\n    F += S1(C) + (C & (D ^ E) ^ E) + 0xC24B8B70UL + w[10]; B += F;\n    F += S0(G) + ((G & H) | (A & (G | H)));\n    w[11] = w[11] + s0(w[12]) + w[ 4] + s1(w[ 9]);\n    E += S1(B) + (B & (C ^ D) ^ D) + 0xC76C51A3UL + w[11]; A += E;\n    E += S0(F) + ((F & G) | (H & (F | G)));\n    w[12] = w[12] + s0(w[13]) + w[ 5] + s1(w[10]);\n    D += S1(A) + (A & (B ^ C) ^ C) + 0xD192E819UL + w[12]; H += D;\n    D += S0(E) + ((E & F) | (G & (E | F)));\n    w[13] = w[13] + s0(w[14]) + w[ 6] + s1(w[11]);\n    C += S1(H) + (H & (A ^ B) ^ B) + 0xD6990624UL + w[13]; G += C;\n    C += S0(D) + ((D & E) | (F & (D | E)));\n    w[14] = w[14] + s0(w[15]) + w[ 7] + s1(w[12]);\n    B += S1(G) + (G & (H ^ A) ^ A) + 0xF40E3585UL + w[14]; F += B;\n    B += S0(C) + ((C & D) | (E & (C | D)));\n    w[15] = w[15] + s0(w[ 0]) + w[ 8] + s1(w[13]);\n    A += S1(F) + (F & (G ^ H) ^ H) + 0x106AA070UL + w[15]; E += A;\n    A += S0(B) + ((B & C) | (D & (B | C)));\n    w[ 0] = w[ 0] + s0(w[ 1]) + w[ 9] + s1(w[14]);\n    H += S1(E) + (E & (F ^ G) ^ G) + 0x19A4C116UL + w[ 0]; D += H;\n    H += S0(A) + ((A & B) | (C & (A | B)));\n    w[ 1] = w[ 1] + s0(w[ 2]) + w[10] + s1(w[15]);\n    G += S1(D) + (D & (E ^ F) ^ F) + 0x1E376C08UL + w[ 1]; C += G;\n    G += S0(H) + ((H & A) | (B & (H | A)));\n    w[ 2] = w[ 2] + s0(w[ 3]) + w[11] + s1(w[ 0]);\n    F += S1(C) + (C & (D ^ E) ^ E) + 0x2748774CUL + w[ 2]; B += F;\n    F += S0(G) + ((G & H) | (A & (G | H)));\n    w[ 3] = w[ 3] + s0(w[ 4]) + w[12] + s1(w[ 1]);\n    E += S1(B) + (B & (C ^ D) ^ D) + 0x34B0BCB5UL + w[ 3]; A += E;\n    E += S0(F) + ((F & G) | (H & (F | G)));\n    w[ 4] = w[ 4] + s0(w[ 5]) + w[13] + s1(w[ 2]);\n    D += S1(A) + (A & (B ^ C) ^ C) + 0x391C0CB3UL + w[ 4]; H += D;\n    D += S0(E) + ((E & F) | (G & (E | F)));\n    w[ 5] = w[ 5] + s0(w[ 6]) + w[14] + s1(w[ 3]);\n    C += S1(H) + (H & (A ^ B) ^ B) + 0x4ED8AA4AUL + w[ 5]; G += C;\n    C += S0(D) + ((D & E) | (F & (D | E)));\n    w[ 6] = w[ 6] + s0(w[ 7]) + w[15] + s1(w[ 4]);\n    B += S1(G) + (G & (H ^ A) ^ A) + 0x5B9CCA4FUL + w[ 6]; F += B;\n    B += S0(C) + ((C & D) | (E & (C | D)));\n    w[ 7] = w[ 7] + s0(w[ 8]) + w[ 0] + s1(w[ 5]);\n    A += S1(F) + (F & (G ^ H) ^ H) + 0x682E6FF3UL + w[ 7]; E += A;\n    A += S0(B) + ((B & C) | (D & (B | C)));\n    w[ 8] = w[ 8] + s0(w[ 9]) + w[ 1] + s1(w[ 6]);\n    H += S1(E) + (E & (F ^ G) ^ G) + 0x748F82EEUL + w[ 8]; D += H;\n    H += S0(A) + ((A & B) | (C & (A | B)));\n    w[ 9] = w[ 9] + s0(w[10]) + w[ 2] + s1(w[ 7]);\n    G += S1(D) + (D & (E ^ F) ^ F) + 0x78A5636FUL + w[ 9]; C += G;\n    G += S0(H) + ((H & A) | (B & (H | A)));\n    w[10] = w[10] + s0(w[11]) + w[ 3] + s1(w[ 8]);\n    F += S1(C) + (C & (D ^ E) ^ E) + 0x84C87814UL + w[10]; B += F;\n    F += S0(G) + ((G & H) | (A & (G | H)));\n    w[11] = w[11] + s0(w[12]) + w[ 4] + s1(w[ 9]);\n    E += S1(B) + (B & (C ^ D) ^ D) + 0x8CC70208UL + w[11]; A += E;\n    E += S0(F) + ((F & G) | (H & (F | G)));\n    w[12] = w[12] + s0(w[13]) + w[ 5] + s1(w[10]);\n    D += S1(A) + (A & (B ^ C) ^ C) + 0x90BEFFFAUL + w[12]; H += D;\n    D += S0(E) + ((E & F) | (G & (E | F)));\n    w[13] = w[13] + s0(w[14]) + w[ 6] + s1(w[11]);\n    C += S1(H) + (H & (A ^ B) ^ B) + 0xA4506CEBUL + w[13]; G += C;\n    C += S0(D) + ((D & E) | (F & (D | E)));\n    w[14] = w[14] + s0(w[15]) + w[ 7] + s1(w[12]);\n    B += S1(G) + (G & (H ^ A) ^ A) + 0xBEF9A3F7UL + w[14]; F += B;\n    B += S0(C) + ((C & D) | (E & (C | D)));\n    w[15] = w[15] + s0(w[ 0]) + w[ 8] + s1(w[13]);\n    A += S1(F) + (F & (G ^ H) ^ H) + 0xC67178F2UL + w[15]; E += A;\n    A += S0(B) + ((B & C) | (D & (B | C)));\n\n    /* update H0 - H7 */\n\n    H0 += A;\n    H1 += B;\n    H2 += C;\n    H3 += D;\n    H4 += E;\n    H5 += F;\n    H6 += G;\n    H7 += H;\n\n    /* clear temp variables */\n\n    A = B = C = D = E = F = G = H = 0;\n    memset(w, 0, sizeof(w));\n}\n\n\n/* ntru_crypto_sha2()\n *\n * This routine provides all operations for a SHA-256 hash,\n * and the use of SHA-256 for DSA signing and key generation.\n * It may be used to initialize, update, or complete a message digest,\n * or any combination of those actions, as determined by the SHA_INIT flag,\n * the in_len parameter, and the SHA_FINISH flag, respectively.\n *\n * When in_len == 0 (no data to hash), the parameter, in, may be NULL.\n * When the SHA_FINISH flag is not set, the parameter, md, may be NULL.\n *\n * Initialization may be standard or use a specified initialization vector,\n * and is indicated by setting the SHA_INIT flag.\n * Setting init = NULL specifies standard initialization.  Otherwise, init\n * points to the array of eight alternate initialization 32-bit words.\n *\n * The hash operation can be updated with any number of input bytes, including\n * zero.\n *\n * Returns SHA_OK on success.\n * Returns SHA_FAIL with corrupted context.\n * Returns SHA_BAD_PARAMETER if  inappropriate NULL pointers are passed.\n * Returns SHA_OVERFLOW if more than 2^64 - 1 bytes are hashed.\n */\n\nuint32_t\nntru_crypto_sha2(\n    NTRU_CRYPTO_HASH_ALGID  algid,  /*     in - hash algorithm ID */\n    NTRU_CRYPTO_SHA2_CTX   *c,      /* in/out - pointer to SHA-2 context */\n    uint32_t const         *init,   /*     in - pointer to alternate */\n                                    /*          initialization - may be NULL */\n    uint8_t const          *in,     /*     in - pointer to input data - */\n                                    /*          may be NULL if in_len == 0 */\n    uint32_t                in_len, /*     in - number of input data bytes */\n    uint32_t                flags,  /*     in - INIT, FINISH flags */\n    uint8_t                *md)     /*    out - address for message digest -\n                                     *          may be NULL if not FINISH */\n{\n    uint32_t    in_blk[16];         /* input block */\n    uint32_t    space;\n    uint8_t    *d = NULL;\n\n    /* check error conditions */\n\n    if (algid != NTRU_CRYPTO_HASH_ALGID_SHA256)\n    {\n        SHA_RET(SHA_BAD_PARAMETER)\n    }\n    \n    if (!c || (in_len && !in) || ((flags & SHA_FINISH) && !md))\n    {\n        SHA_RET(SHA_BAD_PARAMETER)\n    }\n    \n    /* initialize context if requested */\n\n    if (flags & SHA_INIT)\n    {\n        /* init chaining state */\n\n        if (!init)                            /* standard initialization */\n        {\n\n            c->state[0] = H0_SHA256_INIT;     /* standard SHA-256 init */\n            c->state[1] = H1_SHA256_INIT;\n            c->state[2] = H2_SHA256_INIT;\n            c->state[3] = H3_SHA256_INIT;\n            c->state[4] = H4_SHA256_INIT;\n            c->state[5] = H5_SHA256_INIT;\n            c->state[6] = H6_SHA256_INIT;\n            c->state[7] = H7_SHA256_INIT;\n\n        }\n        else\n        {\n            /* Support for SHA-224 etc is disabled */\n            SHA_RET(SHA_BAD_PARAMETER);\n        }\n\n        /* init bit count and number of unhashed data bytes */\n\n        c->num_bits_hashed[0] = 0;\n        c->num_bits_hashed[1] = 0;\n        c->unhashed_len = 0;\n    }\n\n    /* determine space left in unhashed data buffer */\n\n    if (c->unhashed_len > 63)\n    {\n        SHA_RET(SHA_FAIL)\n    }\n\n    space = 64 - c->unhashed_len;\n\n    /* process input if it exists */\n\n    if (in_len)\n    {\n        /* update count of bits hashed */\n\n        {\n            uint32_t    bits0, bits1;\n\n            bits0 = in_len << 3;\n            bits1 = in_len >> 29;\n            \n            if ((c->num_bits_hashed[0] += bits0) < bits0)\n            {\n                bits1++;\n            }\n            \n            if ((c->num_bits_hashed[1] += bits1) < bits1)\n            {\n                memset((uint8_t *) c, 0, sizeof(NTRU_CRYPTO_SHA2_CTX));\n                memset((char *) in_blk, 0, sizeof(in_blk));\n                SHA_RET(SHA_OVERFLOW)\n            }\n        }\n\n        /* process input bytes */\n\n        if (in_len < space)\n        {\n\n            /* input does not fill block buffer:\n             * add input to buffer\n             */\n\n            memcpy(c->unhashed + c->unhashed_len, in, in_len);\n            c->unhashed_len += in_len;\n\n        }\n        else\n        {\n            uint32_t    blks;\n\n            /* input will fill block buffer:\n             *  fill unhashed data buffer,\n             *  convert to block buffer,\n             *  and process block\n             */\n\n            in_len -= space;\n            \n            for (d = c->unhashed + c->unhashed_len; space; space--)\n            {\n                *d++ = *in++;\n            }\n            \n            ntru_crypto_msbyte_2_uint32(in_blk, (uint8_t const *) c->unhashed,\n                                        16);\n            sha2_blk((uint32_t const *) in_blk, c->state);\n\n            /* process any remaining full blocks */\n\n            for (blks = in_len >> 6; blks--; in += 64)\n            {\n                ntru_crypto_msbyte_2_uint32(in_blk, in, 16);\n                sha2_blk((uint32_t const *) in_blk, c->state);\n            }\n\n            /* put any remaining input in the unhashed data buffer */\n\n            in_len &= 0x3f;\n            memcpy(c->unhashed, in, in_len);\n            c->unhashed_len = in_len;\n        }\n    }\n\n    /* complete message digest if requested */\n\n    if (flags & SHA_FINISH)\n    {\n        space = 64 - c->unhashed_len;\n\n        /* add 0x80 padding byte to the unhashed data buffer\n         * (there is always space since the buffer can't be full)\n         */\n\n        d = c->unhashed + c->unhashed_len;\n        *d++ = 0x80;\n        space--;\n\n        /* check for space for bit count */\n\n        if (space < 8)\n        {\n            /* no space for count:\n             *  fill remainder of unhashed data buffer with zeros,\n             *  convert to input block,\n             *  process block,\n             *  fill all but 8 bytes of unhashed data buffer with zeros\n             */\n\n            memset(d, 0, space);\n            ntru_crypto_msbyte_2_uint32(in_blk,\n                                        (uint8_t const *) c->unhashed, 16);\n            sha2_blk((uint32_t const *) in_blk, c->state);\n            memset(c->unhashed, 0, 56);\n\n        }\n        else\n        {\n            /* fill unhashed data buffer with zeros,\n             *  leaving space for bit count\n             */\n\n            for (space -= 8; space; space--)\n            {\n                *d++ = 0;\n            }\n        }\n\n        /* convert partially filled unhashed data buffer to input block and\n         *  add bit count to input block\n         */\n\n        ntru_crypto_msbyte_2_uint32(in_blk, (uint8_t const *) c->unhashed,\n                                    14);\n        in_blk[14] = c->num_bits_hashed[1];\n        in_blk[15] = c->num_bits_hashed[0];\n\n        /* process last block */\n\n        sha2_blk((uint32_t const *) in_blk, c->state);\n\n        /* copy result to message digest buffer */\n\n        ntru_crypto_uint32_2_msbyte(md, c->state, 8);\n        \n        /* clear context and stack variables */\n\n        memset((uint8_t *) c, 0, sizeof(NTRU_CRYPTO_SHA2_CTX));\n        memset((char *) in_blk, 0, sizeof(in_blk));\n    }\n\n    SHA_RET(SHA_OK)\n}\n\n","/******************************************************************************\n * NTRU Cryptography Reference Source Code\n * Copyright (c) 2009-2013, by Security Innovation, Inc. All rights reserved. \n *\n * ntru_crypto_sha256.c is a component of ntru-crypto.\n *\n * Copyright (C) 2009-2013  Security Innovation\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n *****************************************************************************/\n \n/******************************************************************************\n *\n * File: ntru_crypto_sha256.c\n *\n * Contents: Routines implementing the SHA-256 hash calculations.\n *\n *****************************************************************************/\n\n#include \"ntru_crypto_sha256.h\"\n\n\n/* ntru_crypto_sha256_init\n *\n * This routine performs standard initialization of the SHA-256 state.\n *\n * Returns SHA_OK on success.\n * Returns SHA_FAIL with corrupted context.\n * Returns SHA_BAD_PARAMETER if inappropriate NULL pointers are passed.\n */\n\nuint32_t\nntru_crypto_sha256_init(\n    NTRU_CRYPTO_SHA2_CTX *c)        /* in/out - pointer to SHA-2 context */\n{\n    return ntru_crypto_sha2(NTRU_CRYPTO_HASH_ALGID_SHA256, c, NULL, NULL, 0,\n                            SHA_INIT, NULL);\n}\n\n\n/* ntru_crypto_sha256_update\n *\n * This routine processes input data and updates the SHA-256 hash calculation.\n *\n * Returns SHA_OK on success.\n * Returns SHA_FAIL with corrupted context.\n * Returns SHA_BAD_PARAMETER if inappropriate NULL pointers are passed.\n * Returns SHA_OVERFLOW if more than 2^64 - 1 bytes are hashed.\n */\n\nuint32_t\nntru_crypto_sha256_update(\n    NTRU_CRYPTO_SHA2_CTX *c,         /* in/out - pointer to SHA-2 context */\n    uint8_t const        *data,      /*     in - pointer to input data */\n    uint32_t              data_len)  /*     in - no. of bytes of input data */\n{\n    return ntru_crypto_sha2(NTRU_CRYPTO_HASH_ALGID_SHA256, c, NULL, data,\n                            data_len, SHA_DATA_ONLY, NULL);\n}\n\n\n/* ntru_crypto_sha256_final\n *\n * This routine completes the SHA-256 hash calculation and returns the\n * message digest.\n * \n * Returns SHA_OK on success.\n * Returns SHA_FAIL with corrupted context.\n * Returns SHA_BAD_PARAMETER if inappropriate NULL pointers are passed.\n * Returns SHA_OVERFLOW if more than 2^64 - 1 bytes are hashed.\n */\n\nuint32_t\nntru_crypto_sha256_final(\n    NTRU_CRYPTO_SHA2_CTX *c,        /* in/out - pointer to SHA-2 context */\n    uint8_t              *md)       /*    out - address for message digest */\n{\n    return ntru_crypto_sha2(NTRU_CRYPTO_HASH_ALGID_SHA256, c, NULL, NULL, 0,\n                            SHA_FINISH, md);\n}\n\n\n/* ntru_crypto_sha256_digest\n *\n * This routine computes a SHA-256 message digest.\n *\n * Returns SHA_OK on success.\n * Returns SHA_FAIL with corrupted context.\n * Returns SHA_BAD_PARAMETER if inappropriate NULL pointers are passed.\n * Returns SHA_OVERFLOW if more than 2^64 - 1 bytes are hashed.\n */\n\nuint32_t\nntru_crypto_sha256_digest(\n    uint8_t const  *data,           /*  in - pointer to input data */\n    uint32_t        data_len,       /*  in - number of bytes of input data */\n    uint8_t        *md)             /* out - address for message digest */\n{\n    NTRU_CRYPTO_SHA2_CTX c;\n\n    return ntru_crypto_sha2(NTRU_CRYPTO_HASH_ALGID_SHA256, &c, NULL, data,\n                            data_len, SHA_INIT | SHA_FINISH, md);\n}\n\n","#include \"randombytes.h\"\n#include \"ntru_crypto.h\"\n#include \"ntru_crypto_ntru_encrypt_param_sets.h\"\n\n\nDRBG_HANDLE drbg;\nuint16_t public_key_len;\nuint16_t private_key_len;\nuint16_t cyphertext_len;\nuint16_t plaintext_len;\n\n\nuint32_t dbrg_randombytes (uint8_t *out, uint32_t num_bytes) {\n\trandombytes_buf(out, num_bytes);\n\tDRBG_RET(DRBG_OK);\n}\n\nvoid ntrujs_init () {\n\trandombytes_stir();\n\tntru_crypto_drbg_external_instantiate(\n\t\t(RANDOM_BYTES_FN) &dbrg_randombytes,\n\t\t&drbg\n\t);\n\n\tNTRU_ENCRYPT_PARAM_SET* params_data\t=\n\t\tntru_encrypt_get_params_with_id(PARAMS)\n\t;\n\n\tntru_crypto_ntru_encrypt_keygen(\n\t\tdrbg,\n\t\tPARAMS,\n\t\t&public_key_len,\n\t\tNULL,\n\t\t&private_key_len,\n\t\tNULL\n\t);\n\n\tcyphertext_len\t= public_key_len - 5;\n\tplaintext_len\t= params_data->m_len_max;\n}\n\nint ntrujs_public_key_bytes () {\n\treturn public_key_len;\n}\n\nint ntrujs_private_key_bytes () {\n\treturn private_key_len;\n}\n\nint ntrujs_encrypted_bytes () {\n\treturn cyphertext_len;\n}\n\nint ntrujs_decrypted_bytes () {\n\treturn plaintext_len;\n}\n\nint ntrujs_keypair (\n\tuint8_t* public_key,\n\tuint8_t* private_key\n) {\n\treturn ntru_crypto_ntru_encrypt_keygen(\n\t\tdrbg,\n\t\tPARAMS,\n\t\t&public_key_len,\n\t\tpublic_key,\n\t\t&private_key_len,\n\t\tprivate_key\n\t);\n}\n\nint ntrujs_encrypt (\n\tuint8_t* message,\n\tint message_len,\n\tuint8_t* public_key,\n\tuint8_t* cyphertext\n) {\n\treturn ntru_crypto_ntru_encrypt(\n\t\tdrbg,\n\t\tpublic_key_len,\n\t\tpublic_key,\n\t\tmessage_len,\n\t\tmessage,\n\t\t&cyphertext_len,\n\t\tcyphertext\n\t);\n}\n\nint ntrujs_decrypt (\n\tuint8_t* cyphertext,\n\tuint8_t* private_key,\n\tuint8_t* decrypted\n) {\n\tuint16_t decrypted_len\t= plaintext_len;\n\n\tint rc\t= ntru_crypto_ntru_decrypt(\n\t\tprivate_key_len,\n\t\tprivate_key,\n\t\tcyphertext_len,\n\t\tcyphertext,\n\t\t&decrypted_len,\n\t\tdecrypted\n\t);\n\n\tif (rc == NTRU_OK) {\n\t\treturn decrypted_len;\n\t}\n\telse {\n\t\treturn -rc;\n\t}\n}\n"]}